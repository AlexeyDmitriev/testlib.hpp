/* This is autogenerated file
 * PLEASE DO NOT EDIT IT DIRECTLY!
 * You may clone our public repository, edit what you need and then rebuild.
 *
 * Repository URL: git://github.com/AlexeyDmitriev/testlib.hpp.git
 * Bug tracker: https://github.com/AlexeyDmitriev/testlib.hpp/issues
 *
 * testlib.hpp version 0.2.0
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 * You are free to use and change it without any fee.
 */
#pragma once
#include <type_traits>

template<typename T>
class Generator {
public:
	typedef T type;
};

template<typename T, typename = std::true_type>
class DefaultGenerator;
#pragma once

#include <sstream>
#include <type_traits>
#include <iterator>
#pragma once
#include <type_traits>
template<typename T>
class Reader{
public:
	typedef T type;
};

template<typename T, typename = std::true_type>
class DefaultReader;

template <typename... All>
struct firstType;
template <typename First, typename... Other>
struct firstType<First, Other...>{
	typedef First type;
};

template <>
struct firstType<>{
	typedef void type;
};


template <typename T>
inline std::string toString(const T& value){
	std::stringstream ss;
	ss << value;
	return ss.str();
}

template <>
inline std::string toString(const std::string& value){
	return value;
}

template <typename T, typename U>
inline std::string separated(T start, T end, U separator) {
	std::stringstream ss;
	for(T current = start; current != end; ++current) {
		if(current != start)
			ss << separator;
		ss << *current;
	}
	return ss.str();
}

template <typename T, typename U>
inline std::string separated(const T& collection, U&& separator) {
	return separated(std::begin(collection), std::end(collection), std::forward<U>(separator));
}

template <typename T>
inline std::string rangeToString(T start, T end) {
	return '[' + separated(start, end, ", ") + ']';
}
template <typename T>
inline std::string toPrint(T value){
	const size_t MAX_LENGTH = 70;
	std::string str = toString(value);
	if(str.length() <= MAX_LENGTH)
		return "\"" + str + "\"";
	else
		return "\"" + str.substr(0, MAX_LENGTH / 2) + "..." 
		            + str.substr(str.length() - MAX_LENGTH / 2) + "\"";
}

template <>
inline std::string toPrint<char>(char value){
	if(value == '\n')
		return "EOLN";
	if(value == '\r')
		return "CR";
	if(value == ' ')
		return "' '";
	if(value >= 0 && value < ' ')
		return "'#" + toString(static_cast<int>(value)) + "'";
	return "'" + toString(value) + "'";
}

template <>
inline std::string toPrint<const char*>(const char* string){
	return toString(string);
}

template<typename T, typename U>
inline std::string expectation(T&& expected, U&& found){
	return toPrint(expected) + " expected, " + toPrint(found) + " found";
}

template <typename ReaderT, typename T, typename Result>
using if_reader = typename std::enable_if<std::is_base_of<Reader<T>, ReaderT>::value,Result>::type;

template<typename Integral>
inline std::string englishEnding(Integral n){
    if (n / 10 % 10 == 1)
        return "th";
    if (n % 10 == 1)
        return "st";
    if (n % 10 == 2)
        return "nd";
    if (n % 10 == 3)
        return "rd";
    return "th";
}


#ifdef TESTLIB_DEBUG
	#define TESTLIB_ASSERT(x) \
		if(!(x)) { \
			std::cerr << "Assertion failed: " << #x << std::endl; \
			std::exit(1); \
		}
#else
	#define TESTLIB_ASSERT(x)
#endif
	
#pragma once

#include <ctime>
#include <cstdint>
#include <cstddef>
#include <climits>
#include <limits>
#include <stdexcept>
#include <type_traits>
#include <utility>
#include <iterator>
#pragma once


#include <cstdlib>
#include <stdexcept>
#include <string>
#include <cassert>
#include <map>
#pragma once

#ifndef OK_EXIT_CODE
	#define OK_EXIT_CODE 0
#endif

#ifndef WA_EXIT_CODE
	#ifdef EJUDGE
		#define WA_EXIT_CODE 5
	#else
		#define WA_EXIT_CODE 1
	#endif
#endif

#ifndef PE_EXIT_CODE
	#ifdef EJUDGE
		#define PE_EXIT_CODE 4
	#else
		#define PE_EXIT_CODE 2
	#endif
#endif

#ifndef FAIL_EXIT_CODE
	#ifdef EJUDGE
		#define FAIL_EXIT_CODE 6
	#else
		#define FAIL_EXIT_CODE 3
	#endif
#endif
	
#ifndef PARTIALLY_EXIT_CODE
	#ifdef TESTSYS
		#define PARTIALLY_EXIT_CODE 50
	#else
		#define PARTIALLY_EXIT_CODE 0
	#endif
#endif

#if ( _WIN32 || __WIN32__ || _WIN64 || __WIN64__ )
	#define ON_WINDOWS
#endif
	
class Verdict {
public:
	enum _verdict{
		OK,
		FAIL,
		WA,
		PE
	};
	/* implicit */ Verdict(_verdict verdict):result(verdict){}
	Verdict partially(int result){
		return Verdict(result + VERDICTS);
	}
	
	int exitCode(){
		switch(result){
			case OK:
				return OK_EXIT_CODE;
			case WA:
				return WA_EXIT_CODE;
			case FAIL:
				return FAIL_EXIT_CODE;
			case PE:
				return PE_EXIT_CODE;
			default:
				return PARTIALLY_EXIT_CODE + result - VERDICTS;
		}
	}
	std::string shortMessage(){
		switch(result){
			case OK:
				return "OK";
			case WA:
				return "Wrong answer";
			case FAIL:
				return "FAIL";
			case PE:
				return "Wrong output format";
			default:
				return "Partially correct";
		}
	}

	std::string outcome(){
		switch(result){
			case OK:
				return "accepted";
			case WA:
				return "wrong-answer";
			case FAIL:
				return "fail";
			case PE:
				return "presentation-error";
			default:
				return "partially-correct";
		}
	}
	bool operator == (Verdict right){
		return result == right.result;
	}
	bool operator != (Verdict right){
		return result != right.result;
	}
private:
	const static int VERDICTS = PE + 1;
	explicit Verdict(int result):result(result){}
	int result;
};

class VerdictException : std::exception {
public:
	Verdict verdict;
	std::string message;
	VerdictException(Verdict verdict, const std::string& str): verdict(verdict), message(str){}
};
class Random {
public:
	static const size_t MAX_BITS = sizeof(uintmax_t) * CHAR_BIT;
	Random(uint64_t seed){
		this->seed = (seed ^ 0x5DEECE66DL) & ((one() << 48) - 1);
	}

	bool nextBit() {
		return _nextBits(1);
	}

	uintmax_t nextBits(size_t bitCount) {
		if(bitCount > MAX_BITS){
			throw std::out_of_range("Can't fit this number of bits in uintmax_t");
		}
		uintmax_t v = _nextBits(bitCount & 31);
		bitCount >>= 5;
		while(bitCount--){
			v <<= 32;
			v ^= _nextBits(32);
		}
		return v;
	}

	template<typename T, typename... Args>
	typename std::enable_if<!std::is_base_of<Generator<T>, typename firstType<Args...>::type>::value,T>::type next(Args&&... args){
		return DefaultGenerator<T>().generate(*this, std::forward<Args>(args)...);
	}
	
	template<typename T, typename U, typename... Args>
	typename std::enable_if<std::is_base_of<Generator<T>, U>::value,T>::type next(U generator, Args&&... args){
		return generator.generate(*this, std::forward<Args>(args)...);
	}

	template<typename T, typename... Args>
	void fill(T& variable, Args&&... args) {
		variable = next<T>(std::forward<Args>(args)...);
	}
	
	template <typename RAI>
	void shuffle(RAI first, RAI last) {
		using std::swap;
		ptrdiff_t len = last - first;
		while(first != last){
			--len;
			swap(*first, first[next<ptrdiff_t>(0, len)]);
			++first;
		}
	}

	template <typename T, typename OI, typename... Args> 
	void fillN(size_t n, OI iterator, Args&&... args){
		for(size_t i = 0; i < n; ++i){
			*(iterator++) = next<T>(std::forward<Args>(args)...);
		}
	}

	template <typename FI, typename... Args>
	void fillRange(FI first, FI last, Args&&... args) {
		for(;first != last;++first){
			*first = next<typename std::remove_reference<decltype(*first)>::type>(std::forward<Args>(args)...);
		}
	}

	template <typename Iterator>
	typename std::iterator_traits<Iterator>::value_type any(Iterator begin, Iterator end) {
		auto len = std::distance(begin, end);
		if(begin == end)
			throw VerdictException(Verdict::FAIL, "Empty range to generate any");
		return *std::next(begin, next<decltype(len)>(0, len - 1));
	}

	template <typename T>
	auto any(const T& collection) -> decltype(any(collection.begin(), collection.end())) {
		return any(collection.begin(), collection.end());
	}
private:
	uint64_t seed;
	
	uint32_t _nextBits(size_t bitCount){
		seed = (seed * 0x5DEECE66DL + 0xBL) & ((one() << 48) - 1);
		return uint32_t(seed >> (48 - bitCount));
	}

	uintmax_t one(){
		return 1;
	}

};
#pragma once

#pragma once
#include <iostream>
#include <functional>
#include <type_traits>
#include <cstdio>
#include <memory>
#pragma once
#include <iostream>
class StreamReader {
public:
	virtual int get() = 0;
	virtual int peek() = 0;
	
	virtual ~StreamReader() {}
};
class StdStreamReader : public StreamReader {
public:
	StdStreamReader(std::istream& stream):stream(stream){}
	
	int get(){
		return stream.get();
	}
	
	int peek(){
		return stream.peek();
	}
	virtual ~StdStreamReader() {}
private:
	std::istream& stream;
};

class File {
public:
	File():stream(nullptr), opened(false){}
	File(FILE* stream): stream(stream), opened(false){}
	void open(const char* name, const char* format){
		opened = true;
		stream = fopen(name, format);
	}
	bool fail() const {
		return stream == nullptr;
	}
	~File() {
		if(opened && stream)
			fclose(stream);
	}
	FILE* stream;
private:
	bool opened;
};

class BufferedFileReader : public StreamReader{
public:
	BufferedFileReader(const File& file): file(file){}
	int get() {
		if(!fill())
			return EOF;
		return buffer[position++];
	}
	
	int peek() {
		if(!fill())
			return EOF;
		return buffer[position];
	}
	virtual ~BufferedFileReader(){}
private:
	bool fill(){
		if(position < bufferSize)
			return true;
		bufferSize = fread(buffer, 1, BUFFER_SIZE, file.stream);
		position = 0;
		return bufferSize > 0;
	}
	static const int BUFFER_SIZE = 100000;
	char buffer[BUFFER_SIZE];
	int position = 0;
	int bufferSize = 0;
	const File& file;
};

class IStream {
public:
	enum class Mode{
		STRICT,
		NON_STRICT
	};
	IStream(std::unique_ptr<StreamReader> stream, Mode mode):stream(std::move(stream)), mode(mode){}
	
	template<typename T, typename... Args>
	typename std::enable_if<!std::is_base_of<Reader<T>, typename firstType<Args...>::type>::value,T>::type read(Args&&... args){
		return read<T>(DefaultReader<T>(), std::forward<Args>(args)...);
	}
	
	template<typename T, typename U, typename... Args>
	typename std::enable_if<std::is_base_of<Reader<T>, U>::value,T>::type read(U reader, Args&&... args){
		return reader.read(*this, std::forward<Args>(args)...);
	}
	
	template<typename T, typename... Args>
	T namedRead(const std::string& name, Args... args){
		try {
			return read<T>(std::forward<Args>(args)...);
		}
		catch(VerdictException& prev){
			throw VerdictException(prev.verdict, name + ": " + prev.message);
		}
	}
	
	template<typename T, typename... Args>
	void fill(T& result, Args&&... args){
		result = read<T>(std::forward<Args>(args)...);
	}
	
	template<typename T>
	IStream& operator >> (T& result){
		fill(result);
		return *this;
	}
	
	char readChar(){
		skipUnused();
		int c = get();
		if(c == EOF)
			quit(Verdict::PE, expectation("Character", "EOF"));				
		return c;
	}
	
	void readChar(char expected){
		while (peek() != expected){
			if(peek() == EOF)
				quit(Verdict::PE, expectation(expected, "EOF"));
			else if (isSkippable(peek()))
				get();
			else 
				quit(Verdict::PE, expectation(expected, char(peek())));
		}
		get();
	}
	
	void readSpace(){
		readChar(' ');
	}
	
	void readEoln(){
	#ifdef ON_WINDOWS
		readChar('\r');
	#endif
		readChar('\n');
	}
	
	void readEof(){
		skipUnused();
		int c = get();
		if(c != EOF)
			quit(Verdict::PE, expectation("EOF", char(c)));
	}
	
	std::string readToken(){	
		buffer.clear();
		skipUnused();
		while(!isWhiteSpace(stream->peek()))
			buffer += stream->get();
		
		if(buffer.empty()){
			if(stream->peek() == EOF)
				quit(Verdict::PE, expectation("Token", "EOF"));
			else
				quit(Verdict::PE, expectation("Token", char(stream->peek())));
		}
		return buffer;
	}
	
	int peek() const {
		return stream->peek();
	}
	int get(){
		return stream->get();
	}
	
	void setStrict(){
		mode = Mode::STRICT;
	}
	void setNonStrict(){
		mode = Mode::NON_STRICT;
	}
	
	Mode getMode() const {
		return mode;
	}
	
	bool seekEoln(){
	#ifdef ON_WINDOWS
		char eoln = '\r';
	#else
		char eoln = '\n';
	#endif
		while (peek() != eoln){
			if (isSkippable(peek()) && peek() != EOF)
				get();
			else 
				return false;
		}
		return true;
	}
	
	bool seekEof(){
		while (peek() != EOF){
			if (isSkippable(peek()))
				get();
			else
				return false;
		}
		return true;
	}
	
	virtual void quit(Verdict verdict, const std::string& message) = 0;
	virtual ~IStream(){}
private:
	std::string buffer;
	std::unique_ptr<StreamReader> stream;
	Mode mode;
	bool isSkippable(int c) const {
		return isWhiteSpace(c) && (mode == Mode::NON_STRICT);
	}
	bool isWhiteSpace(int c) const {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF;
	}
	void skipUnused() {
		int c = peek();
		while (isSkippable(c) && c != EOF){
			get();
			c = peek();
		}
	}
};

class FailIStream : public IStream {
public:
	FailIStream(std::unique_ptr<StreamReader> stream, Mode mode):IStream(std::move(stream), mode){}
	virtual void quit(Verdict, const std::string& message) override {
		throw VerdictException(Verdict::FAIL, message);
	}
	virtual ~FailIStream(){}
};

class OutputIStream : public IStream {
public:
	OutputIStream(std::unique_ptr<StreamReader> stream, Mode mode):IStream(std::move(stream), mode){}
	virtual void quit(Verdict verdict, const std::string& message) override {
		throw VerdictException(verdict, message);
	}
	virtual ~OutputIStream(){}
};
#include <algorithm>
#include <limits>
#include <string>
#include <type_traits>
#include <cmath>

template<typename T>
inline bool isInfinite(T value){
	return value == std::numeric_limits<T>::infinity() || value == -std::numeric_limits<T>::infinity();
}
template<typename T>
inline bool isNaN(T value){
	return value != value;
}

template <typename T>
class FloatReader : public Reader<T> {
public:
	T read(IStream& stream) const {
		std::string input = stream.readToken();
		const char* usedValue = input.c_str();
		size_t length = input.length();
		if(input[0] == '-') {
			++usedValue;
			--length;
		}
		if(length == 0)
			stream.quit(Verdict::PE, expectation("Float", input));

		if(usedValue[0] == '0' && length > 1 && usedValue[1] != '.')
			stream.quit(Verdict::PE, expectation("Float", input));
		if(usedValue[0] == '.')
			stream.quit(Verdict::PE, expectation("Float", input));
		if(usedValue[length - 1] == '.')
			stream.quit(Verdict::PE, expectation("Float", input));

		bool wasPoint = false;
		for (size_t i = 0; i < length; ++i) {
			char digit = usedValue[i];
			if(digit == '.') {
				if (wasPoint)
					stream.quit(Verdict::PE, expectation("Float", input));
				wasPoint = true;
			}
			else {
				if(digit < '0' || digit > '9')
					stream.quit(Verdict::PE, expectation("Float", input));
			}
		}

		std::stringstream ss(input);
		T result;
		
		ss >> result;
		if(!ss || isNaN(result) || isInfinite(result))
			stream.quit(Verdict::PE, expectation("Float", input));
		return result;
	}
	T read(IStream& stream, T min, T max) const {
		T result = read(stream);
		if(result < min || result > max)
			stream.quit(Verdict::WA, "Float violates the range [" + toString(min) + "," + toString(max) + "]");
		return result; 
	}
};

template<typename T>
class DefaultReader<T, typename std::is_floating_point<T>::type> : public FloatReader<T> {};

template<typename T>
inline bool areClose(T expected, T value, T epsilon){
	return (std::abs(value - expected) / std::max(1.0, expected)) < epsilon;
}
#pragma once
#include <utility>
#include <string>
#pragma once
#include <string>

class Separator{
private:
	std::string separator;
public:
	/*implicit*/ Separator(char c): separator(1, c){}
	/*implicit*/ Separator(const char* s): separator(s){}
	/*implicit*/ Separator(const std::string& s): separator(s){}
	void read(IStream& stream) const {
		for(char c: separator){
			stream.readChar(c);
		}
	}
};

template<typename T, typename U>
class DefaultReader<std::pair<T, U>> : Reader<std::pair<T, U>>{
public:
	
	typedef std::pair<T, U> type;
	type read(IStream& stream) const {
		return read(stream, defaultSeparator(stream));
	}
	type read(IStream& stream, const Separator& separator) const {
		return read(stream, DefaultReader<T>(), DefaultReader<U>(), separator);
	}
	
	template <typename ReaderT, typename ReaderU>
	if_reader<ReaderT, T, if_reader<ReaderU, U, type>> read(IStream& stream, const ReaderT& readerT, const ReaderU& readerU) const {
		return read(stream, readerT, readerU, defaultSeparator(stream));
	}
	
	template <typename ReaderT, typename ReaderU>
	if_reader<ReaderT, T, if_reader<ReaderU, U, type>> read(IStream& stream, const ReaderT& readerT, const ReaderU& readerU, const Separator& separator) const {
		T t = stream.namedRead<T>("first", readerT);
		separator.read(stream);
		U u = stream.namedRead<U>("second", readerU);
		return std::make_pair(std::move(t), std::move(u));
	}
	template <typename ReaderT>
	if_reader<ReaderT, T, type> read(IStream& stream, const ReaderT& readerT) const {
		static_assert(std::is_same<T, U>::value, "You may use only reader only for pair<T, T>");
		return read(stream, readerT, defaultSeparator(stream));
	}
	
	template <typename ReaderT>
	if_reader<ReaderT, T, type> read(IStream& stream, const ReaderT& readerT, const Separator& separator) const {
		static_assert(std::is_same<T, U>::value, "You may use only reader only for pair<T, T>");
		return read(stream, readerT, readerT, separator);
	}
	
private:
	Separator defaultSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}
};
#pragma once
#include <type_traits>
template <typename T>
struct is_char : public std::false_type{};

template <>
struct is_char<char> : public std::true_type{};

template <>
struct is_char<signed char> : public std::true_type{};

template <>
struct is_char<unsigned char> : public std::true_type{};


template<typename T>
class DefaultReader<T, typename is_char<T>::type> : Reader<T>{
public:
	T read(IStream& stream) const {
		return stream.readChar();
	}
	T read(IStream& stream, const std::string& allowed) const {
		T result = read(stream);
		for(char c: allowed)
			if(result == c)
				return result;
		stream.quit(Verdict::PE, expectation("One of \"" + allowed + "\"", result));
		assert(false);
	}
};
#pragma once
#include <string>

template <>
class DefaultReader<std::string>: public Reader<std::string>{
public:
	std::string read(IStream& stream) const {
		return stream.readToken();
	}
	std::string read(IStream& stream, std::size_t maxLength) const {
		std::string ret = read(stream);
		if(ret.length() > maxLength)
			stream.quit(Verdict::WA, "Too long string");
		return ret;
	}
};

class LineReader: public Reader<std::string> {
public:
	std::string read(IStream& stream) const {
		std::string ret;
		while(!lineEnd(stream.peek())){
			ret += (char)stream.get();
		}
		if(stream.peek() != EOF || stream.getMode() == IStream::Mode::STRICT)
			stream.readEoln();
		return ret;
	}
	std::string read(IStream& stream, std::size_t maxLength) const {
		std::string ret = read(stream);
		if(ret.length() > maxLength)
			stream.quit(Verdict::WA, "Too long line");
		return ret;
	}
private:
	bool lineEnd(int c) const {
		return c == '\n' || c == '\r' || c == EOF;
	}
};
#pragma once

#include <limits>
#include <string>
#include <type_traits>
#include <vector>
#include <algorithm>

template <typename T, int radix = 10>
class IntegerReader : public Reader<T>{
	static_assert(radix >= 2 && radix <= 36, "Radix must be in range [2..36]");
public:
	enum class Case {
		DEFAULT,
		LOWER,
		UPPER,
		BOTH,
	};
	explicit IntegerReader(Case allowedCase = Case::DEFAULT): allowedCase(allowedCase) {}
	T read(IStream& stream) const {
		Case streamCase = effectiveCase(stream);
		std::string input = stream.readToken();
		bool is_signed = std::numeric_limits<T>::is_signed;
		if(!is_signed && input[0] == '-')
			stream.quit(Verdict::PE, expectation("Unsigned integer", input));
		
		const char* usedValue = input.c_str();
		size_t length = input.length();
		bool negative = false;
		if(input[0] == '-'){
			negative = true;
			++usedValue;
			--length;
		}
		
		static const std::vector<int> maxArray = absToArray(std::numeric_limits<T>::max());
		if(length > maxArray.size())
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		
		static std::vector<int> digits(maxArray.size());
		
		for(size_t i = 0; i < length; ++i){
			try {
				digits[i] = digitValue(usedValue[i], streamCase);
			}
			catch(NotDigitException& e){
				stream.quit(Verdict::PE, expectation("Digit", e.character));
			}
			if(digits[i] >= radix)
				stream.quit(Verdict::PE, expectation("Digit in radix " + toString(radix), usedValue[i]));
		}
		static const std::vector<int> minArray = absToArray(std::numeric_limits<T>::min());
		if(negative && digits == minArray){
			return std::numeric_limits<T>::min();
		}
		
		if(digits.empty())
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		if(digits[0] == 0 && (negative || length > 1))
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		if(length == maxArray.size() && digits > maxArray)
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		T result = 0;
		for(size_t i = 0; i < length; ++i){
			result = result * radix + digits[i];
		}
		
		
		if(negative){
			result = -result;
		}
		
		return result;
	}
	T read(IStream& stream, T min, T max) const {
		T result = read(stream);
		if(result < min || result > max)
			stream.quit(Verdict::WA, "Integer violates the range [" + toString(min) + "," + toString(max) + "]");
		return result;
	}
private:
	struct NotDigitException : public std::exception {
		public:
			NotDigitException(char c):character(c){}
		char character;
	};
	Case effectiveCase(IStream& stream) const {
		if(allowedCase != Case::DEFAULT)
			return allowedCase;
		return stream.getMode() == IStream::Mode::STRICT ? Case::LOWER : Case::BOTH;
	}
	Case allowedCase;
	std::vector<int> absToArray(T value) const {
		bool negative = value < 0;
		std::vector<int> result;
		while(value != 0){
			if(negative)
				result.push_back(- (value % radix));
			else
				result.push_back(value % radix);
			value /= radix;
		}
		std::reverse(result.begin(), result.end());
		return result;
	}
	
	T digitValue(char c, Case streamCase) const {
		if(c >= '0' && c <= '9')
			return c - '0';
		if(lowerAllowed(streamCase) && c >= 'a' && c <= 'z')
			return c - 'a' + 10;
		if(upperAllowed(streamCase) && c >= 'A' && c <= 'Z')
			return c - 'A' + 10;
		throw NotDigitException(c);
	}
	
	bool lowerAllowed(Case _case) const {
		return _case == Case::LOWER || _case == Case::BOTH;
	}
	
	bool upperAllowed(Case _case) const {
		return _case == Case::UPPER || _case == Case::BOTH;
	}
};

template<typename T>
struct is_integer : public std::integral_constant<bool, std::is_integral<T>::value && !is_char<T>::value>{};

template<>
struct is_integer<bool> : public std::false_type {};

template<typename T>
class DefaultReader<T, typename is_integer<T>::type> : public IntegerReader<T>{};

template<typename T>
using HexReader = IntegerReader<T, 16>;
#pragma once
#include <utility>
#include <type_traits>
#include <vector>

template<typename T>
class DefaultReader<std::vector<T>> : Reader<std::vector<T>>{
public:
	typedef std::vector<T> type;
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, size_t numberElements, Reader reader = DefaultReader<T>()) const {
		return read(stream, numberElements, defaultElementsSeparator(stream), reader);
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, size_t numberElements, const Separator& separator, Reader reader = DefaultReader<T>()) const {
		std::vector<T> res;
		res.reserve(numberElements);
		for (size_t i = 0; i < numberElements; i++){
			res.push_back(stream.namedRead<T>("index " + toString(i), reader));
			if (i != numberElements - 1)
				separator.read(stream);
		}
		return res;
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, Reader reader = DefaultReader<T>()) const {
		return read(stream, defaultSizeSeparator(stream), defaultElementsSeparator(stream), reader);
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, const Separator& sizeSeparator, const Separator& elementsSeparator, Reader reader = DefaultReader<T>()) const {
		size_t numberElements =  stream.namedRead<size_t>("Size");
		sizeSeparator.read(stream);
		return read(stream, numberElements, elementsSeparator, reader);
	}
	
private:
	Separator defaultSizeSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? "\n" : "";
	}
	Separator defaultElementsSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}	
};
#pragma once

#pragma once
#include <sstream>
#include <algorithm>
#include <iterator>

#define QUIT(verdict, msg) \
do { \
	std::stringstream ss; \
	ss << msg; \
	throw VerdictException(verdict, ss.str()); \
} \
while (false) \

#define OK(msg) QUIT(Verdict::OK, msg)
#define WA(msg) QUIT(Verdict::WA, msg)
#define FAIL(msg) QUIT(Verdict::FAIL, msg)
#define PE(msg) QUIT(Verdict::PE, msg)

#define ensure(condition) \
do { \
	if(!(condition)) {\
		FAIL("\"" #condition "\" on line "  << __LINE__ << " is false"); \
	} \
} while(false)

#define verify(condition, verdict, message) \
do { \
	if(!(condition)) {\
		QUIT(verdict, message); \
	} \
} while(false)
template <typename T, typename Equal = std::equal_to<T>>
inline void verifyEqual(T&& t, T&& u, Verdict verdict = Verdict::WA, Equal equal = Equal()){
	verify(equal(t, u), verdict, expectation(t, u));
}

template <typename T, typename Compare = std::less<typename std::iterator_traits<T>::value_type>>
inline void verifySorted(T start, T end, Verdict verdict = Verdict::WA, Compare comp = Compare()){
	verify(std::is_sorted(start, end, comp), verdict, expectation("Sorted range", rangeToString(start, end)));
}

template <typename T, typename U>
inline void verifyEqualRanges (T startT, T endT, U startU, U endU, Verdict verdict = Verdict::WA){
	T itT = startT;
	U itU = startU;
	while(true){
		if(itT == endT && itU == endU)
			return;
		if(itT == endT || itU == endU)
			QUIT(verdict, "Length differ, " << expectation(rangeToString(startT, endT), rangeToString(startU, endU)));
		if(*itT != *itU)
			QUIT(verdict, expectation(rangeToString(startT, endT), rangeToString(startU, endU)));
		++itT;
		++itU;
	}
}

template<typename T, typename TReader = DefaultReader<T>>
inline void checkExtraTokensInEnd(IStream& ans, IStream& ouf, size_t alreadyReadTokensNumber, 
	                                TReader reader = DefaultReader<T>()) {
	size_t extraInAnsCount = 0;
	while (!ans.seekEof()) {
		ans.read<T>(reader);
		++extraInAnsCount;
	}

	size_t extraInOufCount = 0;
	while (!ouf.seekEof()) {
		ouf.read<T>(reader);
		++extraInOufCount;
	}

	if (extraInAnsCount) {
		WA("Answer contains longer sequence [length = " 
				<< alreadyReadTokensNumber + extraInAnsCount << "], but output contains "
				<< alreadyReadTokensNumber << " tokens");
	}

	if (extraInOufCount) {
		WA("Output contains longer sequence [length = " 
				<< alreadyReadTokensNumber + extraInOufCount << "], but answer contains "
				<< alreadyReadTokensNumber << " tokens");
	}
}

template<typename T, typename EqualComparator = std::equal_to<T>>
struct AreEqualChecker {
	explicit AreEqualChecker(const EqualComparator& equalComparator = EqualComparator()): equalComparator(equalComparator) {}

	void operator() (const T& ansToken, const T& oufToken) const {
		verifyEqual(ansToken, oufToken, Verdict::WA, equalComparator);
	}

private:
	EqualComparator equalComparator;
};

template<typename T, typename TokensChecker = AreEqualChecker<T>, typename TReader = DefaultReader<T>>
inline void checkToEof(IStream& ans, IStream& ouf, TokensChecker tokensChecker = AreEqualChecker<T>(), 
	                     TReader reader = DefaultReader<T>()) {
	size_t tokensNumber = 0;
	while (!ans.seekEof() && !ouf.seekEof()) {
		T ansToken = ans.read<T>(reader);
		T oufToken = ouf.read<T>(reader);
		++tokensNumber;
		try {
			tokensChecker(ansToken, oufToken);
		} catch(VerdictException& verdict) {
			verdict.message = "Differs in " + std::to_string(tokensNumber) + englishEnding(tokensNumber) 
			           	       + " item: " + verdict.message;
			throw verdict;
		}
	}
	checkExtraTokensInEnd<T>(ans, ouf, tokensNumber, reader);
	OK(tokensNumber << " tokens");
}

template<typename T, typename TokensChecker = AreEqualChecker<T>, typename TReader = DefaultReader<T>>
inline void checkN(IStream& ans, IStream& ouf, size_t tokensNumber, TokensChecker tokensChecker = AreEqualChecker<T>(), 
	                 Reader<T> reader = DefaultReader<T>()) {
	for (size_t tokenNumber = 0; tokenNumber < tokensNumber; ++tokenNumber) {
		T ansToken = ans.read<T>(reader);
		T oufToken = ouf.read<T>(reader);

		try {
			tokensChecker(ansToken, oufToken);
		} catch(VerdictException& verdict) {
			verdict.message = "Differs in " + std::to_string(tokensNumber) + englishEnding(tokensNumber) 
			           	       + " item: " + verdict.message;
			throw verdict;
		}
	}
}

template<typename T>
struct AreClose {
	explicit AreClose(T epsilon): epsilon(epsilon) {}

	bool operator() (const T& lhs, const T& rhs) const {
		return areClose(lhs, rhs, epsilon);
	}

private:
	T epsilon;
};

#pragma once
#include <functional>
#include <utility>

template <typename T>
class ReaderWrapper : public Reader<typename T::type> {
public:
	typedef typename T::type type;
	
	template <typename... Args>
	ReaderWrapper(T reader, Args&& ... args) {
		using namespace std::placeholders;

		lambda = std::bind(
			[reader](IStream& stream, Args... args) {
				return reader.read(stream, args...);
			},
			_1,
			std::forward<Args> (args)...
		);
	}

	type read(IStream& stream) {
		return lambda(stream);
	}
private:
	std::function<type(IStream&)> lambda;
};

template <typename T, typename... Args>
ReaderWrapper<T> make_reader(T reader, Args&&... args) {
	return ReaderWrapper<T>(reader, std::forward<Args> (args)...);
}

template <typename T, typename... Args>
ReaderWrapper<DefaultReader<T>> make_default_reader(Args&&... args) {
	return make_reader(DefaultReader<T>(), std::forward<Args>(args)...);
}
#include <type_traits>

template <typename T>
class DefaultGenerator<T, typename std::is_floating_point<T>::type> : public Generator<T> {
public:
	T generate(Random& rnd, T from, T to) const {
		T diff = to - from;
		T ans = from;
		while(from + diff != from){
			diff /= 2;
			if(rnd.nextBit())
				ans += diff;
		}
		return ans;
	}
};
#pragma once
#include <utility>
#include <string>

template<typename T, typename U>
class DefaultGenerator<std::pair<T, U>> : Generator<std::pair<T, U>>{
public:
	typedef std::pair<T, U> type;
	type generate(Random& rnd) const {
		return generate(rnd, DefaultGenerator<T>(), DefaultGenerator<U>());
	}
	
	template <typename GeneratorT, typename GeneratorU>
	type generate(Random& rnd, const GeneratorT& generatorT, const GeneratorU& generatorU) const {
		//Can't inline here because order of argument calculation is unspecified
		//It would possibly break random stability on different compilers
		T first = rnd.next<T>(generatorT);
		U second = rnd.next<U>(generatorU);
		return std::make_pair(std::move(first), std::move(second));
	}
	
	template <typename GeneratorT>
	type generate(Random& rnd, const GeneratorT& generatorT) const {
		static_assert(std::is_same<T, U>::value, "You may use only generator only for pair<T, T>");
		return generate(rnd, generatorT, generatorT);
	}
};
#pragma once

#include <deque>
#include <vector>
#include <string>
#include <list>
#include <set>
#include <map>

template<typename T, typename U>
inline auto reserveIfExists(T& container, U&& n, int)
	-> decltype(container.reserve(n), void())
{
	container.reserve(n);
}

template<typename T, typename U>
inline void reserveIfExists(T&, U&& n, long){}


template<typename T, typename U>
inline auto addToContainer(T& container, U&& value) -> decltype(container.push_back(value), void()) {
	container.push_back(value);
}

template<typename T, typename U>
inline auto addToContainer(T& container, U&& value) -> decltype(container.insert(value), void()) {
	container.insert(value);
}

template<typename T>
class ContainerGenerator : public Generator<T> {
	typedef typename T::value_type value_type;
	typedef typename T::size_type size_type;
public:
	template<typename... Args>
	T generate(Random& rnd, size_type n, Args&&... args) const {
		T result;
		reserveIfExists(result, n, 0);
		while(result.size() != n) {
			addToContainer(result, rnd.next<value_type>(std::forward<Args>(args)...));
		}
		return result;
	}
};

template<typename T>
class DefaultGenerator<std::vector<T>> : public ContainerGenerator<std::vector<T>> {
};

template <>
class DefaultGenerator<std::string> : public ContainerGenerator<std::string> {
};

template<typename T>
class DefaultGenerator<std::deque<T>> : public ContainerGenerator<std::deque<T>> {
};

template<typename T>
class DefaultGenerator<std::list<T>> : public ContainerGenerator<std::list<T>> {
};

template<typename T>
class DefaultGenerator<std::set<T>> : public ContainerGenerator<std::set<T>> {
};

template<typename K, typename V>
class DefaultGenerator<std::map<K, V>> : public ContainerGenerator<std::map<K, V>> {
};

template<typename T>
class DefaultGenerator<std::multiset<T>> : public ContainerGenerator<std::multiset<T>> {
};

template<typename K, typename V>
class DefaultGenerator<std::multimap<K, V>> : public ContainerGenerator<std::multimap<K, V>> {
};


#pragma once
#include <set>
template <typename T, typename Cmp = std::less<typename T::value_type>>
class UniqueGenerator : public Generator<T> {
	typedef typename T::value_type value_type;
	typedef typename T::size_type size_type;
	Cmp less;
public:
	UniqueGenerator(Cmp less = Cmp()): less(less) {}
	template<typename... Args>
	T generate(Random& rnd, size_type n, Args&&... args) const {
		T result;
		std::set<value_type, Cmp> used(less);
		reserveIfExists(result, n, 0);
		while(used.size() != n){
			auto value = rnd.next<value_type>(std::forward<Args>(args)...);
			if(used.find(value) == used.end()) {
				addToContainer(result, value);
				used.insert(value);
			}
		}
		return result;
	}
};


template<typename T>
class DefaultGenerator<T, typename std::is_integral<T>::type> : public Generator<T>{
	uintmax_t generateMax(Random& rnd) {
		return rnd.nextBits(rnd.MAX_BITS);
	}

	T generateTo (Random& rnd, uintmax_t to) const {
		uintmax_t disallowed = std::numeric_limits<uintmax_t>::max() / to * to;
		uintmax_t number;
		do {
			number = rnd.nextBits(rnd.MAX_BITS);
		}
		while(number >= disallowed);
		return number % to;
	}
public:
	T generate(Random& rnd) const {
		return rnd.nextBits(sizeof(T) * CHAR_BIT);
	}

	T generate(Random& rnd, T l, T r) const {
		if(l > r)
			throw VerdictException(Verdict::FAIL, "DefaultGenerator<int>::generate(): l > r");
		if(l == std::numeric_limits<T>::min() && r == std::numeric_limits<T>::max())
			return generate(rnd);

		return generateTo(rnd, uintmax_t(r) - uintmax_t(l) + uintmax_t(1)) + l;
	}
};

#pragma once
#include <type_traits>
#include <iostream>

template <typename T, typename R, typename X>
class AliasImpl;

template<typename T, typename R>
class AliasImpl<T, R, std::true_type> : public T {
public:
	/*implicit*/ AliasImpl(const T& value): T(value){}
};

template <typename T, typename R>
class AliasImpl<T, R, std::false_type>{
public:
	/*implicit*/ AliasImpl(const T& value): value(value){}
	operator T () const {
		return value;
	}
private:
	T value;
};

template <typename T, typename R>
using Alias = AliasImpl<T, R, typename std::is_class<T>::type>;

template <typename T, typename R>
class DefaultReader<Alias<T,R>> : public Reader<Alias<T,R>> {
	typedef Reader<Alias<T,R>> Base;
public:
	typedef typename Base::type type;
	template<typename... Args>
	type read(Args&&... args) {
		return R().read(std::forward<Args>(args)...);
	}
};

template <typename T, typename G>
class DefaultGenerator<Alias<T,G>> : public Generator<Alias<T, G>> {
public:
	typedef typename Generator<Alias<T, G>>::type type;
	template<typename... Args>
	type generate(Args&&... args) {
		return G().generate(std::forward<Args>(args)...);
	}
};
#pragma once
#include <fstream>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <string>
#include <iostream>

void writeXml(std::ostream& stream, const std::string& str){
	for(char c: str){
		if(c == '&')
			stream << "&amp;";
		else if(c == '"')
			stream << "&quot;";
		else if(c == '<')
			stream << "&lt;";
		else if(c == '>')
			stream << "&gt;";
		else
			stream << c;
	}
}

struct Options{
	FailIStream inf;
	OutputIStream ouf;
	FailIStream ans;
	bool xml;
	Options(): inf(std::unique_ptr<StreamReader>(new BufferedFileReader(input)), IStream::Mode::NON_STRICT),
	           ouf(std::unique_ptr<StreamReader>(new BufferedFileReader(output)), IStream::Mode::NON_STRICT),
	           ans(std::unique_ptr<StreamReader>(new BufferedFileReader(answer)), IStream::Mode::NON_STRICT)
	{}
	std::ostream& out(){
		return fileOutput.is_open() ? fileOutput : std::cout;
	}
	
	void fill(int argc, char** argv){
		xml = false;
		if (argc  < 4 || argc > 6)
		{
			throw VerdictException(Verdict::FAIL,
				"Program must be run with the following arguments: \n" \
				"<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"
			);
		}
		if(argc == 6){
			if(std::strcmp(argv[5], "-APPES") && std::strcmp(argv[5], "-appes")){
				throw VerdictException(Verdict::FAIL,
					"Program must be run with the following arguments: \n" \
					"<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"
				);
			}

			xml = true;
		}

		input.open(argv[1], "r");
		output.open(argv[2], "r");
		answer.open(argv[3], "r");

		if(input.fail() || output.fail() || answer.fail())
			throw VerdictException(Verdict::FAIL, "Can't open files");


		if (argc > 4){
			fileOutput.open(argv[4]);
			if(fileOutput.fail()){
				throw VerdictException(Verdict::FAIL, "Can't open output file to write");
			}
		}
	}
private:
	File input, output, answer;
	std::ofstream fileOutput;
};

#define TESTLIB_CHECK() void check(IStream& inf, IStream& ouf, IStream& ans); \
int main(int argc, char** argv){ \
	Verdict verdict = Verdict::FAIL; \
	std::string message = "No verdict returned"; \
	Options options; \
	try { \
		options.fill(argc, argv); \
		check(options.inf, options.ouf, options.ans); \
	} \
	catch (VerdictException& ex){ \
		verdict = ex.verdict; \
		message = ex.message; \
	} \
	if(verdict == Verdict::OK && !options.ouf.seekEof()){ \
		verdict = Verdict::PE; \
		message = "Extra Information in the output file"; \
	} \
	\
	std::ostream& out = options.out(); \
	if(options.xml){ \
		out << "<?xml version=\"1.0\" encoding=\"windows-1251\"?>" \
			"<result outcome = \"" << verdict.outcome() << "\">"; \
		writeXml(out, message); \
		out << "</result>\n"; \
	} \
	else \
		out << verdict.shortMessage() << ' ' << message << std::endl; \
	return verdict.exitCode(); \
} \
void check(IStream& inf, IStream& ouf, IStream& ans)

#define TESTLIB_VALIDATE() void validate(IStream&); \
int main(){ \
	Verdict verdict = Verdict::OK; \
	std::string message = "No message provided"; \
	FailIStream input(std::unique_ptr<StreamReader>(new BufferedFileReader(File(stdin))), IStream::Mode::STRICT); \
	try { \
		validate(input); \
	} \
	catch(VerdictException& ex){ \
		verdict = ex.verdict; \
		message = ex.message; \
	} \
	if(verdict == Verdict::OK && !input.seekEof()){ \
		verdict = Verdict::FAIL; \
		message = "Extra information in input file"; \
	} \
	if(verdict != Verdict::OK && verdict != Verdict::FAIL){ \
		verdict = Verdict::FAIL; \
		message = "Wrong verdict: " + verdict.shortMessage() + ". Message: " + message; \
	} \
	std::cout << verdict.shortMessage() << " " << message << std::endl; \
	return verdict.exitCode(); \
} \
void validate(IStream& inf)

uint64_t getHash(size_t argc, char** argv)
{
	uint64_t seed = 0, multiplier = 0x5f17;
	uint64_t p = 1;
	for (size_t i = 1; i < argc; ++i) {
		for (size_t j = 0, n = strlen(argv[i]); j < n; ++j) {
			seed += argv[i][j] * p;
			p *= multiplier;
		}
		seed += p * ' ';
		p *= multiplier;
	}
	return seed;
}

class ArgumentsReader {
public:
	template<typename T, typename... Args>
	T get(Args&&... args) {
		rangeCheck();
		std::stringstream ss(argv[cur]);
		FailIStream in(std::unique_ptr<StreamReader>(new StdStreamReader(ss)), IStream::Mode::NON_STRICT);
		return in.read<T>(std::forward<Args>(args)...);
	}
	std::string getRaw() {
		rangeCheck();
		return argv[cur];
	}
	ArgumentsReader (int argc, char** argv): argc(argc), argv(argv), cur(0) {}
private:
	void rangeCheck() {
		++cur;
		if(cur == argc)
			throw VerdictException(Verdict::FAIL, "Too few command-line arguments");
	}
	int argc;
	char** argv;
	int cur;
};

#define TESTLIB_GENERATE() void generate(Random& rnd, ArgumentsReader& args); \
int main(int argc, char** argv) {\
	Verdict verdict = Verdict::OK; \
	\
	Random rnd(getHash(argc, argv)); \
	ArgumentsReader args(argc, argv); \
	try { \
		generate(rnd, args); \
	} \
	catch(VerdictException& ex) { \
		verdict = Verdict::FAIL; \
		std::cerr << "FAIL: " << ex.message << std::endl;\
	} \
	return verdict.exitCode(); \
} \
void generate(Random& rnd, ArgumentsReader& args)

#pragma once
#include <functional>
#include <utility>

template <typename T>
class GeneratorWrapper : public Generator<typename T::type> {
public:
	typedef typename T::type type;
	
	template <typename... Args>
	GeneratorWrapper(T generator, Args&& ... args) {
		using namespace std::placeholders;

		lambda = std::bind(
			[generator](Random& stream, Args... args) {
				return generator.generate(stream, args...);
			},
			_1,
			std::forward<Args> (args)...
		);
	}

	type generate(Random& stream) {
		return lambda(stream);
	}
private:
	std::function<type(Random&)> lambda;
};

template <typename T, typename... Args>
GeneratorWrapper<T> make_generator(T generator, Args&&... args) {
	return GeneratorWrapper<T>(generator, std::forward<Args> (args)...);
}

template <typename T, typename... Args>
GeneratorWrapper<DefaultGenerator<T>> make_default_generator(Args&&... args) {
	return make_generator(DefaultGenerator<T>(), std::forward<Args>(args)...);
}
