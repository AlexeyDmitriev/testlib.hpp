/* This is autogenerated file
 * PLEASE DO NOT EDIT IT DIRECTLY!
 * You may clone our public repository, edit what you need and then rebuild.
 *
 * Repository URL: git://github.com/AlexeyDmitriev/testlib.hpp.git
 * Bug tracker: https://github.com/AlexeyDmitriev/testlib.hpp/issues
 *
 * testlib.hpp version 0.1.0
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 * You are free to use and change it without any fee.
 */

#ifndef OK_EXIT_CODE
	#define OK_EXIT_CODE 0
#endif

#ifndef WA_EXIT_CODE
	#ifdef EJUDGE
		#define WA_EXIT_CODE 5
	#else
		#define WA_EXIT_CODE 1
	#endif
#endif

#ifndef PE_EXIT_CODE
	#ifdef EJUDGE
		#define PE_EXIT_CODE 4
	#else
		#define PE_EXIT_CODE 2
	#endif
#endif

#ifndef FAIL_EXIT_CODE
	#ifdef EJUDGE
		#define FAIL_EXIT_CODE 6
	#else
		#define FAIL_EXIT_CODE 3
	#endif
#endif
	
#ifndef PARTIALLY_EXIT_CODE
	#ifdef TESTSYS
		#define PARTIALLY_EXIT_CODE 50
	#else
		#define PARTIALLY_EXIT_CODE 0
	#endif
#endif
#include <iostream>
class StreamReader {
public:
	virtual int get() = 0;
	virtual int peek() = 0;
	
	virtual ~StreamReader() {}
};
class StdStreamReader : public StreamReader {
public:
	StdStreamReader(std::istream& stream):stream(stream){}
	
	int get(){
		return stream.get();
	}
	
	int peek(){
		return stream.peek();
	}
	virtual ~StdStreamReader() {}
private:
	std::istream& stream;
};

class File {
public:
	File():stream(nullptr), opened(false){}
	File(FILE* stream): stream(stream), opened(false){}
	void open(const char* name, const char* format){
		opened = true;
		stream = fopen(name, format);
	}
	bool fail() const {
		return stream == nullptr;
	}
	~File() {
		if(opened && stream)
			fclose(stream);
	}
	FILE* stream;
private:
	bool opened;
};

class BufferedFileReader : public StreamReader{
public:
	BufferedFileReader(const File& file): file(file){}
	int get() {
		if(!fill())
			return EOF;
		return buffer[position++];
	}
	
	int peek() {
		if(!fill())
			return EOF;
		return buffer[position];
	}
	virtual ~BufferedFileReader(){}
private:
	bool fill(){
		if(position < bufferSize)
			return true;
		bufferSize = fread(buffer, 1, BUFFER_SIZE, file.stream);
		position = 0;
		return bufferSize > 0;
	}
	static const int BUFFER_SIZE = 100000;
	char buffer[BUFFER_SIZE];
	int position = 0;
	int bufferSize = 0;
	const File& file;
};


#include <cstdlib>
#include <stdexcept>
#include <string>
#include <cassert>
#include <map>

#if ( _WIN32 || __WIN32__ || _WIN64 || __WIN64__ )
	#define ON_WINDOWS
#endif
	
class Verdict {
public:
	enum _verdict{
		OK,
		FAIL,
		WA,
		PE
	};
	/* implicit */ Verdict(_verdict verdict):result(verdict){}
	Verdict partially(int result){
		return Verdict(result + VERDICTS);
	}
	
	int exitCode(){
		switch(result){
			case OK:
				return OK_EXIT_CODE;
			case WA:
				return WA_EXIT_CODE;
			case FAIL:
				return FAIL_EXIT_CODE;
			case PE:
				return PE_EXIT_CODE;
			default:
				return PARTIALLY_EXIT_CODE + result - VERDICTS;
		}
	}
	std::string shortMessage(){
		switch(result){
			case OK:
				return "OK";
			case WA:
				return "Wrong answer";
			case FAIL:
				return "FAIL";
			case PE:
				return "Wrong output format";
			default:
				return "Partially correct";
		}
	}

	std::string outcome(){
		switch(result){
			case OK:
				return "accepted";
			case WA:
				return "wrong-answer";
			case FAIL:
				return "fail";
			case PE:
				return "presentation-error";
			default:
				return "partially-correct";
		}
	}
	bool operator == (Verdict right){
		return result == right.result;
	}
	bool operator != (Verdict right){
		return result != right.result;
	}
private:
	const static int VERDICTS = PE + 1;
	explicit Verdict(int result):result(result){}
	int result;
};

class VerdictException : std::exception {
public:
	Verdict verdict;
	std::string message;
	VerdictException(Verdict verdict, const std::string& str): verdict(verdict), message(str){}
};
#include <sstream>
#include <algorithm>
#include <iterator>

#define QUIT(verdict, msg) \
do { \
	std::stringstream ss; \
	ss << msg; \
	throw VerdictException(verdict, ss.str()); \
} \
while (false); \

#define OK(msg) QUIT(Verdict::OK, msg)
#define WA(msg) QUIT(Verdict::WA, msg)
#define FAIL(msg) QUIT(Verdict::FAIL, msg)
#define PE(msg) QUIT(Verdict::PE, msg)

#define ensure(condition) \
do { \
	if(!(condition)) {\
		FAIL("\"" #condition "\" on line "  << __LINE__ << " is false"); \
	} \
} while(false);

#define verify(condition, verdict, message) \
do { \
	if(!(condition)) {\
		QUIT(verdict, message); \
	} \
} while(false);
/*
template <typename T, typename U>
inline void verifyEqual(T&& t, U&& u, Verdict verdict = Verdict::WA){
	verify(t == u, verdict, t << " != " << u);
}

template <typename T>
inline void verifySorted(T start, T end, Verdict verdict = Verdict::WA){
	verify(std::is_sorted(start, end), verdict, expectation("Sorted range", rangeToString(start, end)));
}
*/
template <typename T, typename Equal = std::equal_to<T>>
inline void verifyEqual(T&& t, T&& u, Verdict verdict = Verdict::WA, Equal equal = Equal()){
	verify(equal(t, u), verdict, t << " != " << u);
}

template <typename T, typename Compare = std::less<typename std::iterator_traits<T>::value_type>>
inline void verifySorted(T start, T end, Verdict verdict = Verdict::WA, Compare comp = Compare()){
	verify(std::is_sorted(start, end, comp), verdict, expectation("Sorted range", rangeToString(start, end)));
}

template <typename T, typename U>
inline void verifyEqualRanges (T startT, T endT, U startU, U endU, Verdict verdict = Verdict::WA){
	T itT = startT;
	U itU = startU;
	while(true){
		if(itT == endT && itU == endU)
			return;
		if(itT == endT || itU == endU)
			QUIT(verdict, rangeToString(startT, endT) << " != " << rangeToString(startU, endU));
		if(*itT != *itU)
			QUIT(verdict, rangeToString(startT, endT) << " != " << rangeToString(startU, endU));
		++itT;
		++itU;
	}
}
#include <type_traits>
template<typename T>
class Reader{
public:
	typedef T type;
};

template<typename T, typename = std::true_type>
class DefaultReader;
#include <type_traits>
#include <iostream>

template <typename T, typename R, typename X>
class AliasImpl;

template<typename T, typename R>
class AliasImpl<T, R, std::true_type> : public T {
	static_assert(std::is_base_of<Reader<T>, R>::value, "R must be reader of T");
public:
	/*implicit*/ AliasImpl(const T& value): T(value){}
};

template <typename T, typename R>
class AliasImpl<T, R, std::false_type>{
	static_assert(std::is_base_of<Reader<T>, R>::value, "R must be reader of T");
public:
	/*implicit*/ AliasImpl(const T& value): value(value){}
	operator T () const {
		return value;
	}
private:
	T value;
};

template <typename T, typename R>
using Alias = AliasImpl<T, R, typename std::is_class<T>::type>;

template <typename T, typename R>
class DefaultReader<Alias<T,R>> : public Reader<Alias<T,R>> {
	typedef Reader<Alias<T,R>> Base;
public:
	typedef typename Base::type type;
	template<typename... Args>
	type read(Args&&... args){
		return R().read(std::forward<Args>(args)...);
	}
};

#include <sstream>
#include <type_traits>

template <typename... All>
struct firstType;
template <typename First, typename... Other>
struct firstType<First, Other...>{
	typedef First type;
};

template <>
struct firstType<>{
	typedef void type;
};


template <typename T>
inline std::string toString(const T& value){
	std::stringstream ss;
	ss << value;
	return ss.str();
}

template <>
inline std::string toString(const std::string& value){
	return value;
}

template <typename T>
inline std::string rangeToString(T start, T end){
	std::stringstream ss;
	ss << '[';
	for(T current = start; current != end; ++current){
		if(current != start)
			ss << ", ";
		ss << *current;
	}
	ss << ']';
	return ss.str();
}

template <typename T>
inline std::string toPrint(T value){
	const size_t MAX_LENGTH = 70;
	std::string str = toString(value);
	if(str.length() <= MAX_LENGTH)
		return "\"" + str + "\"";
	else
		return "\"" + str.substr(0, MAX_LENGTH / 2) + "..." 
		            + str.substr(str.length() - MAX_LENGTH / 2) + "\"";
}

template <>
inline std::string toPrint<char>(char value){
	if(value == '\n')
		return "EOLN";
	if(value == '\r')
		return "CR";
	if(value == ' ')
		return "' '";
	if(value >= 0 && value < ' ')
		return "'#" + toString(static_cast<int>(value)) + "'";
	return "'" + toString(value) + "'";
}

template <>
inline std::string toPrint<const char*>(const char* string){
	return toString(string);
}

template<typename T, typename U>
inline std::string expectation(T&& expected, U&& found){
	return toPrint(expected) + " expected, " + toPrint(found) + " found";
}

template <typename ReaderT, typename T, typename Result>
using if_reader = typename std::enable_if<std::is_base_of<Reader<T>, ReaderT>::value,Result>::type;

template<typename Integral>
inline std::string englishEnding(Integral n){
    if (n / 10 % 10 == 1)
        return "th";
    if (n % 10 == 1)
        return "st";
    if (n % 10 == 2)
        return "nd";
    if (n % 10 == 3)
        return "rd";
    return "th";
}
#include <iostream>
#include <functional>
#include <type_traits>
#include <cstdio>
#include <memory>

class IStream {
public:
	enum class Mode{
		STRICT,
		NON_STRICT
	};
	IStream(std::unique_ptr<StreamReader> stream, Mode mode):stream(std::move(stream)), mode(mode){}
	
	template<typename T, typename... Args>
	typename std::enable_if<!std::is_base_of<Reader<T>, typename firstType<Args...>::type>::value,T>::type read(Args&&... args){
		return read<T>(DefaultReader<T>(), std::forward<Args>(args)...);
	}
	
	template<typename T, typename U, typename... Args>
	typename std::enable_if<std::is_base_of<Reader<T>, U>::value,T>::type read(U reader, Args&&... args){
		return reader.read(*this, std::forward<Args>(args)...);
	}
	
	template<typename T, typename... Args>
	T namedRead(const std::string& name, Args... args){
		try {
			return read<T>(std::forward<Args>(args)...);
		}
		catch(VerdictException& prev){
			throw VerdictException(prev.verdict, name + ": " + prev.message);
		}
	}
	
	template<typename T, typename... Args>
	void fill(T& result, Args&&... args){
		result = read<T>(std::forward<Args>(args)...);
	}
	
	template<typename T>
	IStream& operator >> (T& result){
		fill(result);
		return *this;
	}
	
	char readChar(){
		skipUnused();
		int c = get();
		if(c == EOF)
			quit(Verdict::PE, expectation("Character", "EOF"));				
		return c;
	}
	
	void readChar(char expected){
		while (peek() != expected){
			if(peek() == EOF)
				quit(Verdict::PE, expectation(expected, "EOF"));
			else if (isSkippable(peek()))
				get();
			else 
				quit(Verdict::PE, expectation(expected, char(peek())));
		}
		get();
	}
	
	void readSpace(){
		readChar(' ');
	}
	
	void readEoln(){
	#ifdef ON_WINDOWS
		readChar('\r');
	#endif
		readChar('\n');
	}
	
	void readEof(){
		skipUnused();
		int c = get();
		if(c != EOF)
			quit(Verdict::PE, expectation("EOF", char(c)));
	}
	
	std::string readToken(){	
		buffer.clear();
		skipUnused();
		while(!isWhiteSpace(stream->peek()))
			buffer += stream->get();
		
		if(buffer.empty()){
			if(stream->peek() == EOF)
				quit(Verdict::PE, expectation("Token", "EOF"));
			else
				quit(Verdict::PE, expectation("Token", char(stream->peek())));
		}
		return buffer;
	}
	
	int peek() const {
		return stream->peek();
	}
	int get(){
		return stream->get();
	}
	
	void setStrict(){
		mode = Mode::STRICT;
	}
	void setNonStrict(){
		mode = Mode::NON_STRICT;
	}
	
	Mode getMode() const {
		return mode;
	}
	
	bool seekEoln(){
	#ifdef ON_WINDOWS
		char eoln = '\r';
	#else
		char eoln = '\n';
	#endif
		while (peek() != eoln){
			if (isSkippable(peek()) && peek() != EOF)
				get();
			else 
				return false;
		}
		return true;
	}
	
	bool seekEof(){
		while (peek() != EOF){
			if (isSkippable(peek()))
				get();
			else
				return false;
		}
		return true;
	}
	
	virtual void quit(Verdict verdict, const std::string& message) = 0;
	virtual ~IStream(){}
private:
	std::string buffer;
	std::unique_ptr<StreamReader> stream;
	Mode mode;
	bool isSkippable(int c) const {
		return isWhiteSpace(c) && (mode == Mode::NON_STRICT);
	}
	bool isWhiteSpace(int c) const {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF;
	}
	void skipUnused() {
		int c = peek();
		while (isSkippable(c) && c != EOF){
			get();
			c = peek();
		}
	}
};

class FailIStream : public IStream {
public:
	FailIStream(std::unique_ptr<StreamReader> stream, Mode mode):IStream(std::move(stream), mode){}
	virtual void quit(Verdict, const std::string& message) override {
		throw VerdictException(Verdict::FAIL, message);
	}
	virtual ~FailIStream(){}
};

class OutputIStream : public IStream {
public:
	OutputIStream(std::unique_ptr<StreamReader> stream, Mode mode):IStream(std::move(stream), mode){}
	virtual void quit(Verdict verdict, const std::string& message) override {
		throw VerdictException(verdict, message);
	}
	virtual ~OutputIStream(){}
};
#include <type_traits>
template <typename T>
struct is_char : public std::false_type{};

template <>
struct is_char<char> : public std::true_type{};

template <>
struct is_char<signed char> : public std::true_type{};

template <>
struct is_char<unsigned char> : public std::true_type{};


template<typename T>
class DefaultReader<T, typename is_char<T>::type> : Reader<T>{
public:
	T read(IStream& stream) const {
		return stream.readChar();
	}
	T read(IStream& stream, const std::string& allowed) const {
		T result = read(stream);
		for(char c: allowed)
			if(result == c)
				return result;
		stream.quit(Verdict::PE, expectation("One of \"" + allowed + "\"", result));
		assert(false);
	}
};
#include <string>

template <>
class DefaultReader<std::string>: public Reader<std::string>{
public:
	std::string read(IStream& stream) const {
		return stream.readToken();
	}
	std::string read(IStream& stream, std::size_t maxLength) const {
		std::string ret = read(stream);
		if(ret.length() > maxLength)
			stream.quit(Verdict::WA, "Too long string");
		return ret;
	}
};

class LineReader: public Reader<std::string> {
public:
	std::string read(IStream& stream) const {
		std::string ret;
		while(!lineEnd(stream.peek())){
			ret += (char)stream.get();
		}
		if(stream.peek() != EOF || stream.getMode() == IStream::Mode::STRICT)
			stream.readEoln();
		return ret;
	}
	std::string read(IStream& stream, std::size_t maxLength) const {
		std::string ret = read(stream);
		if(ret.length() > maxLength)
			stream.quit(Verdict::WA, "Too long line");
		return ret;
	}
private:
	bool lineEnd(int c) const {
		return c == '\n' || c == '\r' || c == EOF;
	}
};

#include <limits>
#include <string>
#include <type_traits>
#include <vector>
#include <algorithm>

template <typename T, int radix = 10>
class IntegerReader : public Reader<T>{
	static_assert(radix >= 2 && radix <= 36, "Radix must be in range [2..36]");
public:
	enum class Case {
		DEFAULT,
		LOWER,
		UPPER,
		BOTH,
	};
	explicit IntegerReader(Case allowedCase = Case::DEFAULT): allowedCase(allowedCase) {}
	T read(IStream& stream) const {
		Case streamCase = effectiveCase(stream);
		std::string input = stream.readToken();
		bool is_signed = std::numeric_limits<T>::is_signed;
		if(!is_signed && input[0] == '-')
			stream.quit(Verdict::PE, expectation("Unsigned integer", input));
		
		const char* usedValue = input.c_str();
		size_t length = input.length();
		bool negative = false;
		if(input[0] == '-'){
			negative = true;
			++usedValue;
			--length;
		}
		
		static const std::vector<int> maxArray = absToArray(std::numeric_limits<T>::max());
		if(length > maxArray.size())
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		
		static std::vector<int> digits(maxArray.size());
		
		for(size_t i = 0; i < length; ++i){
			try {
				digits[i] = digitValue(usedValue[i], streamCase);
			}
			catch(NotDigitException& e){
				stream.quit(Verdict::PE, expectation("Digit", e.character));
			}
			if(digits[i] >= radix)
				stream.quit(Verdict::PE, expectation("Digit in radix " + toString(radix), usedValue[i]));
		}
		static const std::vector<int> minArray = absToArray(std::numeric_limits<T>::min());
		if(negative && digits == minArray){
			return std::numeric_limits<T>::min();
		}
		
		if(digits.empty())
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		if(digits[0] == 0 && (negative || length > 1))
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		if(length == maxArray.size() && digits > maxArray)
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		T result = 0;
		for(size_t i = 0; i < length; ++i){
			result = result * radix + digits[i];
		}
		
		
		if(negative){
			result = -result;
		}
		
		return result;
	}
	T read(IStream& stream, T min, T max) const {
		T result = read(stream);
		if(result < min || result > max)
			stream.quit(Verdict::WA, "Integer violates the range [" + toString(min) + "," + toString(max) + "]");
		return result;
	}
private:
	struct NotDigitException : public std::exception {
		public:
			NotDigitException(char c):character(c){}
		char character;
	};
	Case effectiveCase(IStream& stream) const {
		if(allowedCase != Case::DEFAULT)
			return allowedCase;
		return stream.getMode() == IStream::Mode::STRICT ? Case::LOWER : Case::BOTH;
	}
	Case allowedCase;
	std::vector<int> absToArray(T value) const {
		bool negative = value < 0;
		std::vector<int> result;
		while(value != 0){
			if(negative)
				result.push_back(- (value % radix));
			else
				result.push_back(value % radix);
			value /= radix;
		}
		std::reverse(result.begin(), result.end());
		return result;
	}
	
	T digitValue(char c, Case streamCase) const {
		if(c >= '0' && c <= '9')
			return c - '0';
		if(lowerAllowed(streamCase) && c >= 'a' && c <= 'z')
			return c - 'a' + 10;
		if(upperAllowed(streamCase) && c >= 'A' && c <= 'Z')
			return c - 'A' + 10;
		throw NotDigitException(c);
	}
	
	bool lowerAllowed(Case _case) const {
		return _case == Case::LOWER || _case == Case::BOTH;
	}
	
	bool upperAllowed(Case _case) const {
		return _case == Case::UPPER || _case == Case::BOTH;
	}
};

template<typename T>
struct is_integer : public std::integral_constant<bool, std::is_integral<T>::value && !is_char<T>::value>{};

template<>
struct is_integer<bool> : public std::false_type {};

template<typename T>
class DefaultReader<T, typename is_integer<T>::type> : public IntegerReader<T>{};

template<typename T>
using HexReader = IntegerReader<T, 16>;

#include <algorithm>
#include <limits>
#include <string>
#include <type_traits>
#include <cmath>

template<typename T>
inline bool isInfinite(T value){
	return value == std::numeric_limits<T>::infinity() || value == -std::numeric_limits<T>::infinity();
}
template<typename T>
inline bool isNaN(T value){
	return value != value;
}

template <typename T>
class FloatReader : public Reader<T> {
public:
	T read(IStream& stream) const {
		std::string input = stream.readToken();
		const char* usedValue = input.c_str();
		size_t length = input.length();
		if(input[0] == '-') {
			++usedValue;
			--length;
		}
		if(length == 0)
			stream.quit(Verdict::PE, expectation("Float", input));

		if(usedValue[0] == '0' && length > 1 && usedValue[1] != '.')
			stream.quit(Verdict::PE, expectation("Float", input));
		if(usedValue[0] == '.')
			stream.quit(Verdict::PE, expectation("Float", input));
		if(usedValue[length - 1] == '.')
			stream.quit(Verdict::PE, expectation("Float", input));

		bool wasPoint = false;
		for (size_t i = 0; i < length; ++i) {
			char digit = usedValue[i];
			if(digit == '.') {
				if (wasPoint)
					stream.quit(Verdict::PE, expectation("Float", input));
				wasPoint = true;
			}
			else {
				if(digit < '0' || digit > '9')
					stream.quit(Verdict::PE, expectation("Float", input));
			}
		}

		std::stringstream ss(input);
		T result;
		
		ss >> result;
		if(!ss || isNaN(result) || isInfinite(result))
			stream.quit(Verdict::PE, expectation("Float", input));
		return result;
	}
	T read(IStream& stream, T min, T max) const {
		T result = read(stream);
		if(result < min || result > max)
			stream.quit(Verdict::WA, "Float violates the range [" + toString(min) + "," + toString(max) + "]");
		return result; 
	}
};

template<typename T>
class DefaultReader<T, typename std::is_floating_point<T>::type> : public FloatReader<T> {};

template<typename T>
inline bool areClose(T expected, T value, T epsilon){
	return (std::abs(value - expected) / std::max(1.0, expected)) < epsilon;
}
#include <fstream>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <string>
#include <iostream>

void writeXml(std::ostream& stream, const std::string& str){
	for(char c: str){
		if(c == '&')
			stream << "&amp;";
		else if(c == '"')
			stream << "&quot;";
		else if(c == '<')
			stream << "&lt;";
		else if(c == '>')
			stream << "&gt;";
		else
			stream << c;
	}
}

struct Options{
	FailIStream inf;
	OutputIStream ouf;
	FailIStream ans;
	bool xml;
	Options(): inf(std::unique_ptr<StreamReader>(new BufferedFileReader(input)), IStream::Mode::NON_STRICT),
	           ouf(std::unique_ptr<StreamReader>(new BufferedFileReader(output)), IStream::Mode::NON_STRICT),
	           ans(std::unique_ptr<StreamReader>(new BufferedFileReader(answer)), IStream::Mode::NON_STRICT)
	{}
	std::ostream& out(){
		return fileOutput.is_open() ? fileOutput : std::cout;
	}
	
	void fill(int argc, char** argv){
		xml = false;
		if (argc  < 4 || argc > 6)
		{
			throw VerdictException(Verdict::FAIL,
				"Program must be run with the following arguments: \n" \
				"<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"
			);
		}
		if(argc == 6){
			if(std::strcmp(argv[5], "-APPES") && std::strcmp(argv[5], "-appes")){
				throw VerdictException(Verdict::FAIL,
					"Program must be run with the following arguments: \n" \
					"<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"
				);
			}

			xml = true;
		}

		input.open(argv[1], "r");
		output.open(argv[2], "r");
		answer.open(argv[3], "r");

		if(input.fail() || output.fail() || answer.fail())
			throw VerdictException(Verdict::FAIL, "Can't open files");


		if (argc > 4){
			fileOutput.open(argv[4]);
			if(fileOutput.fail()){
				throw VerdictException(Verdict::FAIL, "Can't open output file to write");
			}
		}
	}
private:
	File input, output, answer;
	std::ofstream fileOutput;
};

#define TESTLIB_CHECK() void check(IStream& inf, IStream& ouf, IStream& ans); \
int main(int argc, char** argv){ \
	Verdict verdict = Verdict::FAIL; \
	std::string message = "No message provided"; \
	Options options; \
	try { \
		options.fill(argc, argv); \
		check(options.inf, options.ouf, options.ans); \
	} \
	catch (VerdictException& ex){ \
		verdict = ex.verdict; \
		message = ex.message; \
	} \
	if(verdict == Verdict::OK && !options.ouf.seekEof()){ \
		verdict = Verdict::PE; \
		message = "Extra Information in the output file"; \
	} \
	\
	std::ostream& out = options.out(); \
	if(options.xml){ \
		out << "<?xml version=\"1.0\" encoding=\"windows-1251\"?>" \
			"<result outcome = \"" << verdict.outcome() << "\">"; \
		writeXml(out, message); \
		out << "</result>\n"; \
	} \
	else \
		out << verdict.shortMessage() << ' ' << message << std::endl; \
	return verdict.exitCode(); \
} \
void check(IStream& inf, IStream& ouf, IStream& ans)

#define TESTLIB_VALIDATE() void validate(IStream&); \
int main(){ \
	Verdict verdict = Verdict::OK; \
	std::string message = "No message provided"; \
	FailIStream input(std::unique_ptr<StreamReader>(new BufferedFileReader(File(stdin))), IStream::Mode::STRICT); \
	try { \
		validate(input); \
	} \
	catch(VerdictException& ex){ \
		verdict = ex.verdict; \
		message = ex.message; \
	} \
	if(verdict == Verdict::OK && !input.seekEof()){ \
		verdict = Verdict::FAIL; \
		message = "Extra information in input file"; \
	} \
	if(verdict != Verdict::OK && verdict != Verdict::FAIL){ \
		verdict = Verdict::FAIL; \
		message = "Wrong verdict: " + verdict.shortMessage() + ". Message: " + message; \
	} \
	std::cout << verdict.shortMessage() << " " << message << std::endl; \
	return verdict.exitCode(); \
} \
void validate(IStream& inf)
#include <string>

class Separator{
private:
	std::string separator;
public:
	/*implicit*/ Separator(char c): separator(1, c){}
	/*implicit*/ Separator(const char* s): separator(s){}
	/*implicit*/ Separator(const std::string& s): separator(s){}
	void read(IStream& stream) const {
		for(char c: separator){
			stream.readChar(c);
		}
	}
};
#include <utility>
#include <string>

template<typename T, typename U>
class DefaultReader<std::pair<T, U>> : Reader<std::pair<T, U>>{
public:
	
	typedef std::pair<T, U> type;
	type read(IStream& stream) const {
		return read(stream, defaultSeparator(stream));
	}
	type read(IStream& stream, const Separator& separator) const {
		return read(stream, DefaultReader<T>(), DefaultReader<U>(), separator);
	}
	
	template <typename ReaderT, typename ReaderU>
	if_reader<ReaderT, T, if_reader<ReaderU, U, type>> read(IStream& stream, const ReaderT& readerT, const ReaderU& readerU) const {
		return read(stream, readerT, readerU, defaultSeparator(stream));
	}
	
	template <typename ReaderT, typename ReaderU>
	if_reader<ReaderT, T, if_reader<ReaderU, U, type>> read(IStream& stream, const ReaderT& readerT, const ReaderU& readerU, const Separator& separator) const {
		T t = stream.namedRead<T>("first", readerT);
		separator.read(stream);
		U u = stream.namedRead<U>("second", readerU);
		return std::make_pair(std::move(t), std::move(u));
	}
	template <typename ReaderT>
	if_reader<ReaderT, T, type> read(IStream& stream, const ReaderT& readerT) const {
		static_assert(std::is_same<T, U>::value, "You may use only reader only for pair<T, T>");
		return read(stream, readerT, defaultSeparator(stream));
	}
	
	template <typename ReaderT>
	if_reader<ReaderT, T, type> read(IStream& stream, const ReaderT& readerT, const Separator& separator) const {
		static_assert(std::is_same<T, U>::value, "You may use only reader only for pair<T, T>");
		return read(stream, readerT, readerT, separator);
	}
	
private:
	Separator defaultSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}
};
#include <utility>
#include <type_traits>
#include <vector>

template<typename T>
class DefaultReader<std::vector<T>> : Reader<std::vector<T>>{
public:
	typedef std::vector<T> type;
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, size_t numberElements, Reader reader = DefaultReader<T>()) const {
		return read(stream, numberElements, defaultElementsSeparator(stream), reader);
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, size_t numberElements, const Separator& separator, Reader reader = DefaultReader<T>()) const {
		std::vector<T> res;
		res.reserve(numberElements);
		for (size_t i = 0; i < numberElements; i++){
			res.push_back(stream.namedRead<T>("index " + toString(i), reader));
			if (i != numberElements - 1)
				separator.read(stream);
		}
		return res;
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, Reader reader = DefaultReader<T>()) const {
		return read(stream, defaultSizeSeparator(stream), defaultElementsSeparator(stream), reader);
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, const Separator& sizeSeparator, const Separator& elementsSeparator, Reader reader = DefaultReader<T>()) const {
		size_t numberElements =  stream.namedRead<size_t>("Size");
		sizeSeparator.read(stream);
		return read(stream, numberElements, elementsSeparator, reader);
	}
	
private:
	Separator defaultSizeSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? "\n" : "";
	}
	Separator defaultElementsSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}	
};
#include <functional>
#include <utility>
#include <tuple>

template <typename T>
class ReaderWrapper : public Reader<typename T::type> {
public:
	typedef typename T::type type;
	
	template <typename... Args>
	ReaderWrapper(T reader, Args&& ... args) {
		using namespace std::placeholders;

		lambda = std::bind(
			[reader](IStream& stream, Args... args) {
				return reader.read(stream, args...);
			},
			_1,
			std::forward<Args> (args)...
		);
	}

	type read(IStream& stream) {
		return lambda(stream);
	}
private:
	std::function<type(IStream&)> lambda;
};

template <typename T, typename... Args>
ReaderWrapper<T> make_reader(T reader, Args&&... args) {
	return ReaderWrapper<T>(reader, std::forward<Args> (args)...);
}

template <typename T, typename... Args>
ReaderWrapper<DefaultReader<T>> make_default_reader(Args&&... args) {
	return make_reader(DefaultReader<T>(), std::forward<Args>(args)...);
}
