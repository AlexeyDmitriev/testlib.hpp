/* This is autogenerated file
 * PLEASE DO NOT EDIT IT DIRECTLY!
 * You may clone our public repository, edit what you need and then rebuild.
 *
 * Repository URL: git://github.com/AlexeyDmitriev/testlib.hpp.git
 * Bug tracker: https://github.com/AlexeyDmitriev/testlib.hpp/issues
 *
 * testlib.hpp version 0.2.0
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 * You are free to use and change it without any fee.
 */
#pragma once
#include <type_traits>

template<typename T>
class Generator {
public:
	typedef T type;
};

template<typename T, typename = std::true_type>
class DefaultGenerator;
#pragma once

#include <sstream>
#include <type_traits>
#include <iterator>
#pragma once
#include <type_traits>
template<typename T>
class Reader{
public:
	typedef T type;
};

template<typename T, typename = std::true_type>
class DefaultReader;

template <typename... All>
struct firstType;
template <typename First, typename... Other>
struct firstType<First, Other...>{
	typedef First type;
};

template <>
struct firstType<>{
	typedef void type;
};


template <typename T>
inline std::string toString(const T& value){
	std::stringstream ss;
	ss << value;
	return ss.str();
}

template <>
inline std::string toString(const std::string& value){
	return value;
}

template <typename T, typename U>
inline std::string separated(T start, T end, U separator) {
	std::stringstream ss;
	for(T current = start; current != end; ++current) {
		if(current != start)
			ss << separator;
		ss << *current;
	}
	return ss.str();
}

template <typename T, typename U>
inline std::string separated(const T& collection, U&& separator) {
	return separated(std::begin(collection), std::end(collection), std::forward<U>(separator));
}

template <typename T>
inline std::string rangeToString(T start, T end) {
	return '[' + separated(start, end, ", ") + ']';
}
template <typename T>
inline std::string toPrint(T value){
	const size_t MAX_LENGTH = 70;
	std::string str = toString(value);
	if(str.length() <= MAX_LENGTH)
		return "\"" + str + "\"";
	else
		return "\"" + str.substr(0, MAX_LENGTH / 2) + "..." 
		            + str.substr(str.length() - MAX_LENGTH / 2) + "\"";
}

template <>
inline std::string toPrint<char>(char value){
	if(value == '\n')
		return "EOLN";
	if(value == '\r')
		return "CR";
	if(value == ' ')
		return "' '";
	if(value >= 0 && value < ' ')
		return "'#" + toString(static_cast<int>(value)) + "'";
	return "'" + toString(value) + "'";
}

template <>
inline std::string toPrint<const char*>(const char* string){
	return toString(string);
}

template<typename T, typename U>
inline std::string expectation(T&& expected, U&& found){
	return toPrint(expected) + " expected, " + toPrint(found) + " found";
}

template <typename ReaderT, typename T, typename Result>
using if_reader = typename std::enable_if<std::is_base_of<Reader<T>, ReaderT>::value,Result>::type;

template<typename Integral>
inline std::string englishEnding(Integral n){
    if (n / 10 % 10 == 1)
        return "th";
    if (n % 10 == 1)
        return "st";
    if (n % 10 == 2)
        return "nd";
    if (n % 10 == 3)
        return "rd";
    return "th";
}


#ifdef TESTLIB_DEBUG
	#define TESTLIB_ASSERT(x) \
		if(!(x)) { \
			std::cerr << "Assertion failed: " << #x << std::endl; \
			std::exit(1); \
		}
#else
	#define TESTLIB_ASSERT(x)
#endif
	
#pragma once

#include <ctime>
#include <cstdint>
#include <cstddef>
#include <climits>
#include <limits>
#include <stdexcept>
#include <type_traits>
#include <utility>
#include <iterator>
#pragma once


#include <cstdlib>
#include <stdexcept>
#include <string>
#include <cassert>
#include <map>
#pragma once

#ifndef OK_EXIT_CODE
	#define OK_EXIT_CODE 0
#endif

#ifndef WA_EXIT_CODE
	#ifdef EJUDGE
		#define WA_EXIT_CODE 5
	#else
		#define WA_EXIT_CODE 1
	#endif
#endif

#ifndef PE_EXIT_CODE
	#ifdef EJUDGE
		#define PE_EXIT_CODE 4
	#else
		#define PE_EXIT_CODE 2
	#endif
#endif

#ifndef FAIL_EXIT_CODE
	#ifdef EJUDGE
		#define FAIL_EXIT_CODE 6
	#else
		#define FAIL_EXIT_CODE 3
	#endif
#endif
	
#ifndef PARTIALLY_EXIT_CODE
	#ifdef TESTSYS
		#define PARTIALLY_EXIT_CODE 50
	#else
		#define PARTIALLY_EXIT_CODE 0
	#endif
#endif

#if ( _WIN32 || __WIN32__ || _WIN64 || __WIN64__ )
	#define ON_WINDOWS
#endif
	
class Verdict {
public:
	enum _verdict{
		OK,
		FAIL,
		WA,
		PE
	};
	/* implicit */ Verdict(_verdict verdict):result(verdict){}
	Verdict partially(int result){
		return Verdict(result + VERDICTS);
	}
	
	int exitCode(){
		switch(result){
			case OK:
				return OK_EXIT_CODE;
			case WA:
				return WA_EXIT_CODE;
			case FAIL:
				return FAIL_EXIT_CODE;
			case PE:
				return PE_EXIT_CODE;
			default:
				return PARTIALLY_EXIT_CODE + result - VERDICTS;
		}
	}
	std::string shortMessage(){
		switch(result){
			case OK:
				return "OK";
			case WA:
				return "Wrong answer";
			case FAIL:
				return "FAIL";
			case PE:
				return "Wrong output format";
			default:
				return "Partially correct";
		}
	}

	std::string outcome(){
		switch(result){
			case OK:
				return "accepted";
			case WA:
				return "wrong-answer";
			case FAIL:
				return "fail";
			case PE:
				return "presentation-error";
			default:
				return "partially-correct";
		}
	}
	bool operator == (Verdict right){
		return result == right.result;
	}
	bool operator != (Verdict right){
		return result != right.result;
	}
private:
	const static int VERDICTS = PE + 1;
	explicit Verdict(int result):result(result){}
	int result;
};

class VerdictException : std::exception {
public:
	Verdict verdict;
	std::string message;
	VerdictException(Verdict verdict, const std::string& str): verdict(verdict), message(str){}
};
class Random {
public:
	static const size_t MAX_BITS = sizeof(uintmax_t) * CHAR_BIT;
	Random(uint64_t seed){
		this->seed = (seed ^ 0x5DEECE66DL) & ((one() << 48) - 1);
	}

	bool nextBit() {
		return _nextBits(1);
	}

	uintmax_t nextBits(size_t bitCount) {
		if(bitCount > MAX_BITS){
			throw std::out_of_range("Can't fit this number of bits in uintmax_t");
		}
		uintmax_t v = _nextBits(bitCount & 31);
		bitCount >>= 5;
		while(bitCount--){
			v <<= 32;
			v ^= _nextBits(32);
		}
		return v;
	}

	template<typename T, typename... Args>
	typename std::enable_if<!std::is_base_of<Generator<T>, typename firstType<Args...>::type>::value,T>::type next(Args&&... args){
		return DefaultGenerator<T>().generate(*this, std::forward<Args>(args)...);
	}
	
	template<typename T, typename U, typename... Args>
	typename std::enable_if<std::is_base_of<Generator<T>, U>::value,T>::type next(U generator, Args&&... args){
		return generator.generate(*this, std::forward<Args>(args)...);
	}

	template<typename T, typename... Args>
	void fill(T& variable, Args&&... args) {
		variable = next<T>(std::forward<Args>(args)...);
	}
	
	template <typename RAI>
	void shuffle(RAI first, RAI last) {
		using std::swap;
		ptrdiff_t len = last - first;
		while(first != last){
			--len;
			swap(*first, first[next<ptrdiff_t>(0, len)]);
			++first;
		}
	}

	template <typename T, typename OI, typename... Args> 
	void fillN(size_t n, OI iterator, Args&&... args){
		for(size_t i = 0; i < n; ++i){
			*(iterator++) = next<T>(std::forward<Args>(args)...);
		}
	}

	template <typename FI, typename... Args>
	void fillRange(FI first, FI last, Args&&... args) {
		for(;first != last;++first){
			*first = next<typename std::remove_reference<decltype(*first)>::type>(std::forward<Args>(args)...);
		}
	}

	template <typename Iterator>
	typename std::iterator_traits<Iterator>::value_type any(Iterator begin, Iterator end) {
		auto len = std::distance(begin, end);
		if(begin == end)
			throw VerdictException(Verdict::FAIL, "Empty range to generate any");
		return *std::next(begin, next<decltype(len)>(0, len - 1));
	}

	template <typename T>
	auto any(const T& collection) -> decltype(any(collection.begin(), collection.end())) {
		return any(collection.begin(), collection.end());
	}
private:
	uint64_t seed;
	
	uint32_t _nextBits(size_t bitCount){
		seed = (seed * 0x5DEECE66DL + 0xBL) & ((one() << 48) - 1);
		return uint32_t(seed >> (48 - bitCount));
	}

	uintmax_t one(){
		return 1;
	}

};
#pragma once

#pragma once
#include <iostream>
#include <functional>
#include <type_traits>
#include <cstdio>
#include <memory>
#pragma once
#include <iostream>
class StreamReader {
public:
	virtual int get() = 0;
	virtual int peek() = 0;
	
	virtual ~StreamReader() {}
};
class StdStreamReader : public StreamReader {
public:
	StdStreamReader(std::istream& stream):stream(stream){}
	
	int get(){
		return stream.get();
	}
	
	int peek(){
		return stream.peek();
	}
	virtual ~StdStreamReader() {}
private:
	std::istream& stream;
};

class File {
public:
	File():stream(nullptr), opened(false){}
	File(FILE* stream): stream(stream), opened(false){}
	void open(const char* name, const char* format){
		opened = true;
		stream = fopen(name, format);
	}
	bool fail() const {
		return stream == nullptr;
	}
	~File() {
		if(opened && stream)
			fclose(stream);
	}
	FILE* stream;
private:
	bool opened;
};

class BufferedFileReader : public StreamReader{
public:
	BufferedFileReader(const File& file): file(file){}
	int get() {
		if(!fill())
			return EOF;
		return buffer[position++];
	}
	
	int peek() {
		if(!fill())
			return EOF;
		return buffer[position];
	}
	virtual ~BufferedFileReader(){}
private:
	bool fill(){
		if(position < bufferSize)
			return true;
		bufferSize = fread(buffer, 1, BUFFER_SIZE, file.stream);
		position = 0;
		return bufferSize > 0;
	}
	static const int BUFFER_SIZE = 100000;
	char buffer[BUFFER_SIZE];
	int position = 0;
	int bufferSize = 0;
	const File& file;
};

class IStream {
public:
	enum class Mode{
		STRICT,
		NON_STRICT
	};
	IStream(std::unique_ptr<StreamReader> stream, Mode mode):stream(std::move(stream)), mode(mode){}
	
	template<typename T, typename... Args>
	typename std::enable_if<!std::is_base_of<Reader<T>, typename firstType<Args...>::type>::value,T>::type read(Args&&... args){
		return read<T>(DefaultReader<T>(), std::forward<Args>(args)...);
	}
	
	template<typename T, typename U, typename... Args>
	typename std::enable_if<std::is_base_of<Reader<T>, U>::value,T>::type read(U reader, Args&&... args){
		return reader.read(*this, std::forward<Args>(args)...);
	}
	
	template<typename T, typename... Args>
	T namedRead(const std::string& name, Args... args){
		try {
			return read<T>(std::forward<Args>(args)...);
		}
		catch(VerdictException& prev){
			throw VerdictException(prev.verdict, name + ": " + prev.message);
		}
	}
	
	template<typename T, typename... Args>
	void fill(T& result, Args&&... args){
		result = read<T>(std::forward<Args>(args)...);
	}
	
	template<typename T>
	IStream& operator >> (T& result){
		fill(result);
		return *this;
	}
	
	char readChar(){
		skipUnused();
		int c = get();
		if(c == EOF)
			quit(Verdict::PE, expectation("Character", "EOF"));				
		return c;
	}
	
	void readChar(char expected){
		while (peek() != expected){
			if(peek() == EOF)
				quit(Verdict::PE, expectation(expected, "EOF"));
			else if (isSkippable(peek()))
				get();
			else 
				quit(Verdict::PE, expectation(expected, char(peek())));
		}
		get();
	}
	
	void readSpace(){
		readChar(' ');
	}
	
	void readEoln(){
	#ifdef ON_WINDOWS
		readChar('\r');
	#endif
		readChar('\n');
	}
	
	void readEof(){
		skipUnused();
		int c = get();
		if(c != EOF)
			quit(Verdict::PE, expectation("EOF", char(c)));
	}
	
	std::string readToken(){	
		buffer.clear();
		skipUnused();
		while(!isWhiteSpace(stream->peek()))
			buffer += stream->get();
		
		if(buffer.empty()){
			if(stream->peek() == EOF)
				quit(Verdict::PE, expectation("Token", "EOF"));
			else
				quit(Verdict::PE, expectation("Token", char(stream->peek())));
		}
		return buffer;
	}
	
	int peek() const {
		return stream->peek();
	}
	int get(){
		return stream->get();
	}
	
	void setStrict(){
		mode = Mode::STRICT;
	}
	void setNonStrict(){
		mode = Mode::NON_STRICT;
	}
	
	Mode getMode() const {
		return mode;
	}
	
	bool seekEoln(){
	#ifdef ON_WINDOWS
		char eoln = '\r';
	#else
		char eoln = '\n';
	#endif
		while (peek() != eoln){
			if (isSkippable(peek()) && peek() != EOF)
				get();
			else 
				return false;
		}
		return true;
	}
	
	bool seekEof(){
		while (peek() != EOF){
			if (isSkippable(peek()))
				get();
			else
				return false;
		}
		return true;
	}
	
	virtual void quit(Verdict verdict, const std::string& message) = 0;
	virtual ~IStream(){}
private:
	std::string buffer;
	std::unique_ptr<StreamReader> stream;
	Mode mode;
	bool isSkippable(int c) const {
		return isWhiteSpace(c) && (mode == Mode::NON_STRICT);
	}
	bool isWhiteSpace(int c) const {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF;
	}
	void skipUnused() {
		int c = peek();
		while (isSkippable(c) && c != EOF){
			get();
			c = peek();
		}
	}
};

class FailIStream : public IStream {
public:
	FailIStream(std::unique_ptr<StreamReader> stream, Mode mode):IStream(std::move(stream), mode){}
	virtual void quit(Verdict, const std::string& message) override {
		throw VerdictException(Verdict::FAIL, message);
	}
	virtual ~FailIStream(){}
};

class OutputIStream : public IStream {
public:
	OutputIStream(std::unique_ptr<StreamReader> stream, Mode mode):IStream(std::move(stream), mode){}
	virtual void quit(Verdict verdict, const std::string& message) override {
		throw VerdictException(verdict, message);
	}
	virtual ~OutputIStream(){}
};
#include <algorithm>
#include <limits>
#include <string>
#include <type_traits>
#include <cmath>

template<typename T>
inline bool isInfinite(T value){
	return value == std::numeric_limits<T>::infinity() || value == -std::numeric_limits<T>::infinity();
}
template<typename T>
inline bool isNaN(T value){
	return value != value;
}

template <typename T>
class FloatReader : public Reader<T> {
public:
	T read(IStream& stream) const {
		std::string input = stream.readToken();
		const char* usedValue = input.c_str();
		size_t length = input.length();
		if(input[0] == '-') {
			++usedValue;
			--length;
		}
		if(length == 0)
			stream.quit(Verdict::PE, expectation("Float", input));

		if(usedValue[0] == '0' && length > 1 && usedValue[1] != '.')
			stream.quit(Verdict::PE, expectation("Float", input));
		if(usedValue[0] == '.')
			stream.quit(Verdict::PE, expectation("Float", input));
		if(usedValue[length - 1] == '.')
			stream.quit(Verdict::PE, expectation("Float", input));

		bool wasPoint = false;
		for (size_t i = 0; i < length; ++i) {
			char digit = usedValue[i];
			if(digit == '.') {
				if (wasPoint)
					stream.quit(Verdict::PE, expectation("Float", input));
				wasPoint = true;
			}
			else {
				if(digit < '0' || digit > '9')
					stream.quit(Verdict::PE, expectation("Float", input));
			}
		}

		std::stringstream ss(input);
		T result;
		
		ss >> result;
		if(!ss || isNaN(result) || isInfinite(result))
			stream.quit(Verdict::PE, expectation("Float", input));
		return result;
	}
	T read(IStream& stream, T min, T max) const {
		T result = read(stream);
		if(result < min || result > max)
			stream.quit(Verdict::WA, "Float violates the range [" + toString(min) + "," + toString(max) + "]");
		return result; 
	}
};

template<typename T>
class DefaultReader<T, typename std::is_floating_point<T>::type> : public FloatReader<T> {};

template<typename T>
inline bool areClose(T expected, T value, T epsilon){
	return (std::abs(value - expected) / std::max(1.0, expected)) < epsilon;
}
#pragma once
#include <utility>
#include <string>
#pragma once
#include <string>

class Separator{
private:
	std::string separator;
public:
	/*implicit*/ Separator(char c): separator(1, c){}
	/*implicit*/ Separator(const char* s): separator(s){}
	/*implicit*/ Separator(const std::string& s): separator(s){}
	void read(IStream& stream) const {
		for(char c: separator){
			stream.readChar(c);
		}
	}
};

template<typename T, typename U>
class DefaultReader<std::pair<T, U>> : Reader<std::pair<T, U>>{
public:
	
	typedef std::pair<T, U> type;
	type read(IStream& stream) const {
		return read(stream, defaultSeparator(stream));
	}
	type read(IStream& stream, const Separator& separator) const {
		return read(stream, DefaultReader<T>(), DefaultReader<U>(), separator);
	}
	
	template <typename ReaderT, typename ReaderU>
	if_reader<ReaderT, T, if_reader<ReaderU, U, type>> read(IStream& stream, const ReaderT& readerT, const ReaderU& readerU) const {
		return read(stream, readerT, readerU, defaultSeparator(stream));
	}
	
	template <typename ReaderT, typename ReaderU>
	if_reader<ReaderT, T, if_reader<ReaderU, U, type>> read(IStream& stream, const ReaderT& readerT, const ReaderU& readerU, const Separator& separator) const {
		T t = stream.namedRead<T>("first", readerT);
		separator.read(stream);
		U u = stream.namedRead<U>("second", readerU);
		return std::make_pair(std::move(t), std::move(u));
	}
	template <typename ReaderT>
	if_reader<ReaderT, T, type> read(IStream& stream, const ReaderT& readerT) const {
		static_assert(std::is_same<T, U>::value, "You may use only reader only for pair<T, T>");
		return read(stream, readerT, defaultSeparator(stream));
	}
	
	template <typename ReaderT>
	if_reader<ReaderT, T, type> read(IStream& stream, const ReaderT& readerT, const Separator& separator) const {
		static_assert(std::is_same<T, U>::value, "You may use only reader only for pair<T, T>");
		return read(stream, readerT, readerT, separator);
	}
	
private:
	Separator defaultSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}
};
#pragma once
#include <type_traits>
template <typename T>
struct is_char : public std::false_type{};

template <>
struct is_char<char> : public std::true_type{};

template <>
struct is_char<signed char> : public std::true_type{};

template <>
struct is_char<unsigned char> : public std::true_type{};


template<typename T>
class DefaultReader<T, typename is_char<T>::type> : Reader<T>{
public:
	T read(IStream& stream) const {
		return stream.readChar();
	}
	T read(IStream& stream, const std::string& allowed) const {
		T result = read(stream);
		for(char c: allowed)
			if(result == c)
				return result;
		stream.quit(Verdict::PE, expectation("One of \"" + allowed + "\"", result));
		assert(false);
	}
};
#pragma once
#include <string>

template <>
class DefaultReader<std::string>: public Reader<std::string>{
public:
	std::string read(IStream& stream) const {
		return stream.readToken();
	}
	std::string read(IStream& stream, std::size_t maxLength) const {
		std::string ret = read(stream);
		if(ret.length() > maxLength)
			stream.quit(Verdict::WA, "Too long string");
		return ret;
	}
};

class LineReader: public Reader<std::string> {
public:
	std::string read(IStream& stream) const {
		std::string ret;
		while(!lineEnd(stream.peek())){
			ret += (char)stream.get();
		}
		if(stream.peek() != EOF || stream.getMode() == IStream::Mode::STRICT)
			stream.readEoln();
		return ret;
	}
	std::string read(IStream& stream, std::size_t maxLength) const {
		std::string ret = read(stream);
		if(ret.length() > maxLength)
			stream.quit(Verdict::WA, "Too long line");
		return ret;
	}
private:
	bool lineEnd(int c) const {
		return c == '\n' || c == '\r' || c == EOF;
	}
};
#pragma once

#include <limits>
#include <string>
#include <type_traits>
#include <vector>
#include <algorithm>

template <typename T, int radix = 10>
class IntegerReader : public Reader<T>{
	static_assert(radix >= 2 && radix <= 36, "Radix must be in range [2..36]");
public:
	enum class Case {
		DEFAULT,
		LOWER,
		UPPER,
		BOTH,
	};
	explicit IntegerReader(Case allowedCase = Case::DEFAULT): allowedCase(allowedCase) {}
	T read(IStream& stream) const {
		Case streamCase = effectiveCase(stream);
		std::string input = stream.readToken();
		bool is_signed = std::numeric_limits<T>::is_signed;
		if(!is_signed && input[0] == '-')
			stream.quit(Verdict::PE, expectation("Unsigned integer", input));
		
		const char* usedValue = input.c_str();
		size_t length = input.length();
		bool negative = false;
		if(input[0] == '-'){
			negative = true;
			++usedValue;
			--length;
		}
		
		static const std::vector<int> maxArray = absToArray(std::numeric_limits<T>::max());
		if(length > maxArray.size())
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		
		static std::vector<int> digits(maxArray.size());
		
		for(size_t i = 0; i < length; ++i){
			try {
				digits[i] = digitValue(usedValue[i], streamCase);
			}
			catch(NotDigitException& e){
				stream.quit(Verdict::PE, expectation("Digit", e.character));
			}
			if(digits[i] >= radix)
				stream.quit(Verdict::PE, expectation("Digit in radix " + toString(radix), usedValue[i]));
		}
		static const std::vector<int> minArray = absToArray(std::numeric_limits<T>::min());
		if(negative && digits == minArray){
			return std::numeric_limits<T>::min();
		}
		
		if(digits.empty())
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		if(digits[0] == 0 && (negative || length > 1))
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		if(length == maxArray.size() && digits > maxArray)
			stream.quit(Verdict::PE, expectation("Integer", input));
		
		T result = 0;
		for(size_t i = 0; i < length; ++i){
			result = result * radix + digits[i];
		}
		
		
		if(negative){
			result = -result;
		}
		
		return result;
	}
	T read(IStream& stream, T min, T max) const {
		T result = read(stream);
		if(result < min || result > max)
			stream.quit(Verdict::WA, "Integer violates the range [" + toString(min) + "," + toString(max) + "]");
		return result;
	}
private:
	struct NotDigitException : public std::exception {
		public:
			NotDigitException(char c):character(c){}
		char character;
	};
	Case effectiveCase(IStream& stream) const {
		if(allowedCase != Case::DEFAULT)
			return allowedCase;
		return stream.getMode() == IStream::Mode::STRICT ? Case::LOWER : Case::BOTH;
	}
	Case allowedCase;
	std::vector<int> absToArray(T value) const {
		bool negative = value < 0;
		std::vector<int> result;
		while(value != 0){
			if(negative)
				result.push_back(- (value % radix));
			else
				result.push_back(value % radix);
			value /= radix;
		}
		std::reverse(result.begin(), result.end());
		return result;
	}
	
	T digitValue(char c, Case streamCase) const {
		if(c >= '0' && c <= '9')
			return c - '0';
		if(lowerAllowed(streamCase) && c >= 'a' && c <= 'z')
			return c - 'a' + 10;
		if(upperAllowed(streamCase) && c >= 'A' && c <= 'Z')
			return c - 'A' + 10;
		throw NotDigitException(c);
	}
	
	bool lowerAllowed(Case _case) const {
		return _case == Case::LOWER || _case == Case::BOTH;
	}
	
	bool upperAllowed(Case _case) const {
		return _case == Case::UPPER || _case == Case::BOTH;
	}
};

template<typename T>
struct is_integer : public std::integral_constant<bool, std::is_integral<T>::value && !is_char<T>::value>{};

template<>
struct is_integer<bool> : public std::false_type {};

template<typename T>
class DefaultReader<T, typename is_integer<T>::type> : public IntegerReader<T>{};

template<typename T>
using HexReader = IntegerReader<T, 16>;
#pragma once
#include <utility>
#include <type_traits>
#include <vector>

template<typename T>
class DefaultReader<std::vector<T>> : Reader<std::vector<T>>{
public:
	typedef std::vector<T> type;
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, size_t numberElements, Reader reader = DefaultReader<T>()) const {
		return read(stream, numberElements, defaultElementsSeparator(stream), reader);
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, size_t numberElements, const Separator& separator, Reader reader = DefaultReader<T>()) const {
		std::vector<T> res;
		res.reserve(numberElements);
		for (size_t i = 0; i < numberElements; i++){
			res.push_back(stream.namedRead<T>("index " + toString(i), reader));
			if (i != numberElements - 1)
				separator.read(stream);
		}
		return res;
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, Reader reader = DefaultReader<T>()) const {
		return read(stream, defaultSizeSeparator(stream), defaultElementsSeparator(stream), reader);
	}
	
	template <typename Reader = DefaultReader<T>>
	if_reader<Reader, T, type> read(IStream& stream, const Separator& sizeSeparator, const Separator& elementsSeparator, Reader reader = DefaultReader<T>()) const {
		size_t numberElements =  stream.namedRead<size_t>("Size");
		sizeSeparator.read(stream);
		return read(stream, numberElements, elementsSeparator, reader);
	}
	
private:
	Separator defaultSizeSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? "\n" : "";
	}
	Separator defaultElementsSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}	
};
#pragma once

#pragma once
#include <sstream>
#include <algorithm>
#include <iterator>

#define QUIT(verdict, msg) \
do { \
	std::stringstream ss; \
	ss << msg; \
	throw VerdictException(verdict, ss.str()); \
} \
while (false) \

#define OK(msg) QUIT(Verdict::OK, msg)
#define WA(msg) QUIT(Verdict::WA, msg)
#define FAIL(msg) QUIT(Verdict::FAIL, msg)
#define PE(msg) QUIT(Verdict::PE, msg)

#define ensure(condition) \
do { \
	if(!(condition)) {\
		FAIL("\"" #condition "\" on line "  << __LINE__ << " is false"); \
	} \
} while(false)

#define verify(condition, verdict, message) \
do { \
	if(!(condition)) {\
		QUIT(verdict, message); \
	} \
} while(false)
template <typename T, typename Equal = std::equal_to<T>>
inline void verifyEqual(T&& t, T&& u, Verdict verdict = Verdict::WA, Equal equal = Equal()){
	verify(equal(t, u), verdict, expectation(t, u));
}

template <typename T, typename Compare = std::less<typename std::iterator_traits<T>::value_type>>
inline void verifySorted(T start, T end, Verdict verdict = Verdict::WA, Compare comp = Compare()){
	verify(std::is_sorted(start, end, comp), verdict, expectation("Sorted range", rangeToString(start, end)));
}

template <typename T, typename U>
inline void verifyEqualRanges (T startT, T endT, U startU, U endU, Verdict verdict = Verdict::WA){
	T itT = startT;
	U itU = startU;
	while(true){
		if(itT == endT && itU == endU)
			return;
		if(itT == endT || itU == endU)
			QUIT(verdict, "Length differ, " << expectation(rangeToString(startT, endT), rangeToString(startU, endU)));
		if(*itT != *itU)
			QUIT(verdict, expectation(rangeToString(startT, endT), rangeToString(startU, endU)));
		++itT;
		++itU;
	}
}

template<typename T, typename TReader = DefaultReader<T>>
inline void checkExtraTokensInEnd(IStream& ans, IStream& ouf, size_t alreadyReadTokensNumber, 
	                                TReader reader = DefaultReader<T>()) {
	size_t extraInAnsCount = 0;
	while (!ans.seekEof()) {
		ans.read<T>(reader);
		++extraInAnsCount;
	}

	size_t extraInOufCount = 0;
	while (!ouf.seekEof()) {
		ouf.read<T>(reader);
		++extraInOufCount;
	}

	if (extraInAnsCount) {
		WA("Answer contains longer sequence [length = " 
				<< alreadyReadTokensNumber + extraInAnsCount << "], but output contains "
				<< alreadyReadTokensNumber << " tokens");
	}

	if (extraInOufCount) {
		WA("Output contains longer sequence [length = " 
				<< alreadyReadTokensNumber + extraInOufCount << "], but answer contains "
				<< alreadyReadTokensNumber << " tokens");
	}
}

template<typename T, typename EqualComparator = std::equal_to<T>>
struct AreEqualChecker {
	explicit AreEqualChecker(const EqualComparator& equalComparator = EqualComparator()): equalComparator(equalComparator) {}

	void operator() (const T& ansToken, const T& oufToken) const {
		verifyEqual(ansToken, oufToken, Verdict::WA, equalComparator);
	}

private:
	EqualComparator equalComparator;
};

template<typename T, typename TokensChecker = AreEqualChecker<T>, typename TReader = DefaultReader<T>>
inline void checkToEof(IStream& ans, IStream& ouf, TokensChecker tokensChecker = AreEqualChecker<T>(), 
	                     TReader reader = DefaultReader<T>()) {
	size_t tokensNumber = 0;
	while (!ans.seekEof() && !ouf.seekEof()) {
		T ansToken = ans.read<T>(reader);
		T oufToken = ouf.read<T>(reader);
		++tokensNumber;
		try {
			tokensChecker(ansToken, oufToken);
		} catch(VerdictException& verdict) {
			verdict.message = "Differs in " + std::to_string(tokensNumber) + englishEnding(tokensNumber) 
			           	       + " item: " + verdict.message;
			throw verdict;
		}
	}
	checkExtraTokensInEnd<T>(ans, ouf, tokensNumber, reader);
	OK(tokensNumber << " tokens");
}

template<typename T, typename TokensChecker = AreEqualChecker<T>, typename TReader = DefaultReader<T>>
inline void checkN(IStream& ans, IStream& ouf, size_t tokensNumber, TokensChecker tokensChecker = AreEqualChecker<T>(), 
	                 Reader<T> reader = DefaultReader<T>()) {
	for (size_t tokenNumber = 0; tokenNumber < tokensNumber; ++tokenNumber) {
		T ansToken = ans.read<T>(reader);
		T oufToken = ouf.read<T>(reader);

		try {
			tokensChecker(ansToken, oufToken);
		} catch(VerdictException& verdict) {
			verdict.message = "Differs in " + std::to_string(tokensNumber) + englishEnding(tokensNumber) 
			           	       + " item: " + verdict.message;
			throw verdict;
		}
	}
}

template<typename T>
struct AreClose {
	explicit AreClose(T epsilon): epsilon(epsilon) {}

	bool operator() (const T& lhs, const T& rhs) const {
		return areClose(lhs, rhs, epsilon);
	}

private:
	T epsilon;
};

#pragma once
#include <functional>
#include <utility>

template <typename T>
class ReaderWrapper : public Reader<typename T::type> {
public:
	typedef typename T::type type;
	
	template <typename... Args>
	ReaderWrapper(T reader, Args&& ... args) {
		using namespace std::placeholders;

		lambda = std::bind(
			[reader](IStream& stream, Args... args) {
				return reader.read(stream, args...);
			},
			_1,
			std::forward<Args> (args)...
		);
	}

	type read(IStream& stream) {
		return lambda(stream);
	}
private:
	std::function<type(IStream&)> lambda;
};

template <typename T, typename... Args>
ReaderWrapper<T> make_reader(T reader, Args&&... args) {
	return ReaderWrapper<T>(reader, std::forward<Args> (args)...);
}

template <typename T, typename... Args>
ReaderWrapper<DefaultReader<T>> make_default_reader(Args&&... args) {
	return make_reader(DefaultReader<T>(), std::forward<Args>(args)...);
}
#include <type_traits>

template <typename T>
class DefaultGenerator<T, typename std::is_floating_point<T>::type> : public Generator<T> {
public:
	T generate(Random& rnd, T from, T to) const {
		T diff = to - from;
		T ans = from;
		while(from + diff != from){
			diff /= 2;
			if(rnd.nextBit())
				ans += diff;
		}
		return ans;
	}
};
#pragma once
#include <utility>
#include <string>

template<typename T, typename U>
class DefaultGenerator<std::pair<T, U>> : Generator<std::pair<T, U>>{
public:
	typedef std::pair<T, U> type;
	type generate(Random& rnd) const {
		return generate(rnd, DefaultGenerator<T>(), DefaultGenerator<U>());
	}
	
	template <typename GeneratorT, typename GeneratorU>
	type generate(Random& rnd, const GeneratorT& generatorT, const GeneratorU& generatorU) const {
		//Can't inline here because order of argument calculation is unspecified
		//It would possibly break random stability on different compilers
		T first = rnd.next<T>(generatorT);
		U second = rnd.next<U>(generatorU);
		return std::make_pair(std::move(first), std::move(second));
	}
	
	template <typename GeneratorT>
	type generate(Random& rnd, const GeneratorT& generatorT) const {
		static_assert(std::is_same<T, U>::value, "You may use only generator only for pair<T, T>");
		return generate(rnd, generatorT, generatorT);
	}
};
#pragma once

#include <deque>
#include <vector>
#include <string>
#include <list>
#include <set>
#include <map>

template<typename T, typename U>
inline auto reserveIfExists(T& container, U&& n, int)
	-> decltype(container.reserve(n), void())
{
	container.reserve(n);
}

template<typename T, typename U>
inline void reserveIfExists(T&, U&& n, long){}


template<typename T, typename U>
inline auto addToContainer(T& container, U&& value) -> decltype(container.push_back(value), void()) {
	container.push_back(value);
}

template<typename T, typename U>
inline auto addToContainer(T& container, U&& value) -> decltype(container.insert(value), void()) {
	container.insert(value);
}

template<typename T>
class ContainerGenerator : public Generator<T> {
	typedef typename T::value_type value_type;
	typedef typename T::size_type size_type;
public:
	template<typename... Args>
	T generate(Random& rnd, size_type n, Args&&... args) const {
		T result;
		reserveIfExists(result, n, 0);
		while(result.size() != n) {
			addToContainer(result, rnd.next<value_type>(std::forward<Args>(args)...));
		}
		return result;
	}
};

template<typename T>
class DefaultGenerator<std::vector<T>> : public ContainerGenerator<std::vector<T>> {
};

template <>
class DefaultGenerator<std::string> : public ContainerGenerator<std::string> {
};

template<typename T>
class DefaultGenerator<std::deque<T>> : public ContainerGenerator<std::deque<T>> {
};

template<typename T>
class DefaultGenerator<std::list<T>> : public ContainerGenerator<std::list<T>> {
};

template<typename T>
class DefaultGenerator<std::set<T>> : public ContainerGenerator<std::set<T>> {
};

template<typename K, typename V>
class DefaultGenerator<std::map<K, V>> : public ContainerGenerator<std::map<K, V>> {
};

template<typename T>
class DefaultGenerator<std::multiset<T>> : public ContainerGenerator<std::multiset<T>> {
};

template<typename K, typename V>
class DefaultGenerator<std::multimap<K, V>> : public ContainerGenerator<std::multimap<K, V>> {
};


#pragma once
#include <set>
template <typename T, typename Cmp = std::less<typename T::value_type>>
class UniqueGenerator : public Generator<T> {
	typedef typename T::value_type value_type;
	typedef typename T::size_type size_type;
	Cmp less;
public:
	UniqueGenerator(Cmp less = Cmp()): less(less) {}
	template<typename... Args>
	T generate(Random& rnd, size_type n, Args&&... args) const {
		T result;
		std::set<value_type, Cmp> used(less);
		reserveIfExists(result, n, 0);
		while(used.size() != n){
			auto value = rnd.next<value_type>(std::forward<Args>(args)...);
			if(used.find(value) == used.end()) {
				addToContainer(result, value);
				used.insert(value);
			}
		}
		return result;
	}
};


template<typename T>
class DefaultGenerator<T, typename std::is_integral<T>::type> : public Generator<T>{
	uintmax_t generateMax(Random& rnd) {
		return rnd.nextBits(rnd.MAX_BITS);
	}

	T generateTo (Random& rnd, uintmax_t to) const {
		uintmax_t disallowed = std::numeric_limits<uintmax_t>::max() / to * to;
		uintmax_t number;
		do {
			number = rnd.nextBits(rnd.MAX_BITS);
		}
		while(number >= disallowed);
		return number % to;
	}
public:
	T generate(Random& rnd) const {
		return rnd.nextBits(sizeof(T) * CHAR_BIT);
	}

	T generate(Random& rnd, T l, T r) const {
		if(l > r)
			throw VerdictException(Verdict::FAIL, "DefaultGenerator<int>::generate(): l > r");
		if(l == std::numeric_limits<T>::min() && r == std::numeric_limits<T>::max())
			return generate(rnd);

		return generateTo(rnd, uintmax_t(r) - uintmax_t(l) + uintmax_t(1)) + l;
	}
};

#pragma once
#include <type_traits>
#include <iostream>

template <typename T, typename R, typename X>
class AliasImpl;

template<typename T, typename R>
class AliasImpl<T, R, std::true_type> : public T {
public:
	/*implicit*/ AliasImpl(const T& value): T(value){}
};

template <typename T, typename R>
class AliasImpl<T, R, std::false_type>{
public:
	/*implicit*/ AliasImpl(const T& value): value(value){}
	operator T () const {
		return value;
	}
private:
	T value;
};

template <typename T, typename R>
using Alias = AliasImpl<T, R, typename std::is_class<T>::type>;

template <typename T, typename R>
class DefaultReader<Alias<T,R>> : public Reader<Alias<T,R>> {
	typedef Reader<Alias<T,R>> Base;
public:
	typedef typename Base::type type;
	template<typename... Args>
	type read(Args&&... args) {
		return R().read(std::forward<Args>(args)...);
	}
};

template <typename T, typename G>
class DefaultGenerator<Alias<T,G>> : public Generator<Alias<T, G>> {
public:
	typedef typename Generator<Alias<T, G>>::type type;
	template<typename... Args>
	type generate(Args&&... args) {
		return G().generate(std::forward<Args>(args)...);
	}
};
#pragma once
#include <fstream>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <string>
#include <iostream>

void writeXml(std::ostream& stream, const std::string& str){
	for(char c: str){
		if(c == '&')
			stream << "&amp;";
		else if(c == '"')
			stream << "&quot;";
		else if(c == '<')
			stream << "&lt;";
		else if(c == '>')
			stream << "&gt;";
		else
			stream << c;
	}
}

struct Options{
	FailIStream inf;
	OutputIStream ouf;
	FailIStream ans;
	bool xml;
	Options(): inf(std::unique_ptr<StreamReader>(new BufferedFileReader(input)), IStream::Mode::NON_STRICT),
	           ouf(std::unique_ptr<StreamReader>(new BufferedFileReader(output)), IStream::Mode::NON_STRICT),
	           ans(std::unique_ptr<StreamReader>(new BufferedFileReader(answer)), IStream::Mode::NON_STRICT)
	{}
	std::ostream& out(){
		return fileOutput.is_open() ? fileOutput : std::cout;
	}
	
	void fill(int argc, char** argv){
		xml = false;
		if (argc  < 4 || argc > 6)
		{
			throw VerdictException(Verdict::FAIL,
				"Program must be run with the following arguments: \n" \
				"<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"
			);
		}
		if(argc == 6){
			if(std::strcmp(argv[5], "-APPES") && std::strcmp(argv[5], "-appes")){
				throw VerdictException(Verdict::FAIL,
					"Program must be run with the following arguments: \n" \
					"<input-file> <output-file> <answer-file> [<report-file> [<-appes>]]"
				);
			}

			xml = true;
		}

		input.open(argv[1], "r");
		output.open(argv[2], "r");
		answer.open(argv[3], "r");

		if(input.fail() || output.fail() || answer.fail())
			throw VerdictException(Verdict::FAIL, "Can't open files");


		if (argc > 4){
			fileOutput.open(argv[4]);
			if(fileOutput.fail()){
				throw VerdictException(Verdict::FAIL, "Can't open output file to write");
			}
		}
	}
private:
	File input, output, answer;
	std::ofstream fileOutput;
};

#define TESTLIB_CHECK() void check(IStream& inf, IStream& ouf, IStream& ans); \
int main(int argc, char** argv){ \
	Verdict verdict = Verdict::FAIL; \
	std::string message = "No verdict returned"; \
	Options options; \
	try { \
		options.fill(argc, argv); \
		check(options.inf, options.ouf, options.ans); \
	} \
	catch (VerdictException& ex){ \
		verdict = ex.verdict; \
		message = ex.message; \
	} \
	if(verdict == Verdict::OK && !options.ouf.seekEof()){ \
		verdict = Verdict::PE; \
		message = "Extra Information in the output file"; \
	} \
	\
	std::ostream& out = options.out(); \
	if(options.xml){ \
		out << "<?xml version=\"1.0\" encoding=\"windows-1251\"?>" \
			"<result outcome = \"" << verdict.outcome() << "\">"; \
		writeXml(out, message); \
		out << "</result>\n"; \
	} \
	else \
		out << verdict.shortMessage() << ' ' << message << std::endl; \
	return verdict.exitCode(); \
} \
void check(IStream& inf, IStream& ouf, IStream& ans)

#define TESTLIB_VALIDATE() void validate(IStream&); \
int main(){ \
	Verdict verdict = Verdict::OK; \
	std::string message = "No message provided"; \
	FailIStream input(std::unique_ptr<StreamReader>(new BufferedFileReader(File(stdin))), IStream::Mode::STRICT); \
	try { \
		validate(input); \
	} \
	catch(VerdictException& ex){ \
		verdict = ex.verdict; \
		message = ex.message; \
	} \
	if(verdict == Verdict::OK && !input.seekEof()){ \
		verdict = Verdict::FAIL; \
		message = "Extra information in input file"; \
	} \
	if(verdict != Verdict::OK && verdict != Verdict::FAIL){ \
		verdict = Verdict::FAIL; \
		message = "Wrong verdict: " + verdict.shortMessage() + ". Message: " + message; \
	} \
	std::cout << verdict.shortMessage() << " " << message << std::endl; \
	return verdict.exitCode(); \
} \
void validate(IStream& inf)

uint64_t getHash(size_t argc, char** argv)
{
	uint64_t seed = 0, multiplier = 0x5f17;
	uint64_t p = 1;
	for (size_t i = 1; i < argc; ++i) {
		for (size_t j = 0, n = strlen(argv[i]); j < n; ++j) {
			seed += argv[i][j] * p;
			p *= multiplier;
		}
		seed += p * ' ';
		p *= multiplier;
	}
	return seed;
}

class ArgumentsReader {
public:
	template<typename T, typename... Args>
	T get(Args&&... args) {
		rangeCheck();
		std::stringstream ss(argv[cur]);
		FailIStream in(std::unique_ptr<StreamReader>(new StdStreamReader(ss)), IStream::Mode::NON_STRICT);
		return in.read<T>(std::forward<Args>(args)...);
	}
	std::string getRaw() {
		rangeCheck();
		return argv[cur];
	}
	ArgumentsReader (int argc, char** argv): argc(argc), argv(argv), cur(0) {}
private:
	void rangeCheck() {
		++cur;
		if(cur == argc)
			throw VerdictException(Verdict::FAIL, "Too few command-line arguments");
	}
	int argc;
	char** argv;
	int cur;
};

#define TESTLIB_GENERATE() void generate(Random& rnd, ArgumentsReader& args); \
int main(int argc, char** argv) {\
	Verdict verdict = Verdict::OK; \
	\
	Random rnd(getHash(argc, argv)); \
	ArgumentsReader args(argc, argv); \
	try { \
		generate(rnd, args); \
	} \
	catch(VerdictException& ex) { \
		verdict = Verdict::FAIL; \
		std::cerr << "FAIL: " << ex.message << std::endl;\
	} \
	return verdict.exitCode(); \
} \
void generate(Random& rnd, ArgumentsReader& args)

#pragma once
#include <functional>
#include <utility>

template <typename T>
class GeneratorWrapper : public Generator<typename T::type> {
public:
	typedef typename T::type type;
	
	template <typename... Args>
	GeneratorWrapper(T generator, Args&& ... args) {
		using namespace std::placeholders;

		lambda = std::bind(
			[generator](Random& stream, Args... args) {
				return generator.generate(stream, args...);
			},
			_1,
			std::forward<Args> (args)...
		);
	}

	type generate(Random& stream) {
		return lambda(stream);
	}
private:
	std::function<type(Random&)> lambda;
};

template <typename T, typename... Args>
GeneratorWrapper<T> make_generator(T generator, Args&&... args) {
	return GeneratorWrapper<T>(generator, std::forward<Args> (args)...);
}

template <typename T, typename... Args>
GeneratorWrapper<DefaultGenerator<T>> make_default_generator(Args&&... args) {
	return make_generator(DefaultGenerator<T>(), std::forward<Args>(args)...);
}
#pragma once

#include <type_traits>
#include <cmath>

namespace geometry {
template<typename T>
struct Point2D {
	T x;
	T y;
	Point2D(): x(), y() {}
	Point2D(T x, T y): x(x), y(y) {}

	Point2D& operator += (const Point2D& rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	Point2D& operator -= (const Point2D& rhs) {
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	Point2D operator - () const {
		return Point2D(-x, -y);
	}

	Point2D& operator *= (T c) {
		x *= c;
		y *= c;
		return *this;
	}

	Point2D& operator /= (T c) {
		x /= c;
		y /= c;
		return *this;
	}

	T lengthSquared() const {
		return x * x + y * y;
	}

	auto length() -> decltype(sqrt(x)) const {
		return sqrt(lengthSquared());
		//TODO: compile in VS. add sqrt(int)
	}

	T dotProduct(const Point2D& rhs) const {
		return x * rhs.x + y * rhs.y;
	}

	T crossProduct(const Point2D& rhs) const {
		return x * rhs.y - y * rhs.x;
	}

	auto angle() -> decltype(atan2(y, x)) const {
		return atan2(y, x);
	}
};

template<typename T>
Point2D<T> operator + (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	Point2D<T> copy = lhs;
	return copy += rhs;
}

template<typename T>
Point2D<T> operator - (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	Point2D<T> copy = lhs;
	return copy += rhs;
}

template<typename T>
bool operator < (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	std::less<T> less;
	std::equal_to<T> equal;
	return less(lhs.x, rhs.x) || equal(lhs.x, rhs.x) && less(lhs.y, rhs.y);
}

template<typename T>
bool operator > (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	return rhs < lhs;
}

template <typename T>
bool operator <= (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	return !(lhs > rhs);
}

template <typename T>
bool operator >= (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	return !(lhs < rhs);
}

template<typename T>
bool operator == (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	std::equal_to<T> equal;
	return equal(lhs.x, rhs.x) && equal(lhs.y, rhs.y);
}

template<typename T>
bool operator != (const Point2D<T>& lhs, const Point2D<T>& rhs) {
	return !(lhs == rhs);
}

template<typename T>
Point2D<T> operator * (const Point2D<T>& lhs, const T& rhs){
	Point2D<T> copy = lhs;
	return copy *= rhs;
}

template<typename T>
Point2D<T> operator * (const T& lhs, const Point2D<T>& rhs){
	Point2D<T> copy = rhs;
	return copy *= lhs;
}

template<typename T>
Point2D<T> operator / (const Point2D<T>& lhs, const T& rhs){
	Point2D<T> copy = lhs;
	return copy /= rhs;
}

template<typename T>
struct Point3D {
	T x;
	T y;
	T z;
	Point3D(): x(), y() {}
	Point3D(T x, T y, T z): x(x), y(y), z(z) {}

	Point3D& operator += (const Point3D& rhs) {
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
		return *this;
	}

	Point3D& operator -= (const Point3D& rhs) {
		x -= rhs.x;
		y -= rhs.y;
		z -= rhs.z;
		return *this;
	}

	Point3D operator - () const {
		return Point3D(-x, -y, -z);
	}

	Point3D& operator *= (T c) {
		x *= c;
		y *= c;
		z *= c;
		return *this;
	}

	Point3D& operator /= (T c) {
		x /= c;
		y /= c;
		z /= c;
		return *this;
	}

	T lengthSquared() const {
		return x * x + y * y + z * z;
	}

	auto length() -> decltype(sqrt(std::declval<T>())) const {
		return sqrt(lengthSquared());
	}

	T dotProduct(const Point3D& rhs) const {
		return x * rhs.x + y * rhs.y + z * rhs.z;
	}

	Point3D crossProduct(const Point3D& rhs) const {
		return Point3D(y * rhs.z - z * rhs.y, z * rhs.x - x * rhs.z, x * rhs.y - y * rhs.x);
	}
};

template<typename T>
Point3D<T> operator + (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	Point3D<T> copy = lhs;
	return copy += rhs;
}

template<typename T>
Point3D<T> operator - (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	Point3D<T> copy = lhs;
	return copy += rhs;
}

template<typename T>
bool operator < (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	std::less<T> less;
	std::equal_to<T> equal;
	return less(lhs.x, rhs.x) || 
	      equal(lhs.x, rhs.x) &&  less(lhs.y, rhs.y) ||
	      equal(lhs.x, rhs.x) && equal(lhs.y, rhs.y) && less(lhs.z, rhs.z);
}

template<typename T>
bool operator > (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	return rhs < lhs;
}

template <typename T>
bool operator <= (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	return !(lhs > rhs);
}

template <typename T>
bool operator >= (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	return !(lhs < rhs);
}


template<typename T>
bool operator == (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	std::equal_to<T> equal;
	return equal(lhs.x, rhs.x) &&
	       equal(lhs.y, rhs.y) &&
	       equal(lhs.z, rhs.z);
}

template<typename T>
bool operator != (const Point3D<T>& lhs, const Point3D<T>& rhs) {
	return !(lhs == rhs);
}

template<typename T>
Point3D<T> operator * (const Point3D<T>& lhs, const T& rhs){
	Point3D<T> copy = lhs;
	return copy *= rhs;
}

template<typename T>
Point3D<T> operator * (const T& lhs, const Point3D<T>& rhs){
	Point3D<T> copy = rhs;
	return copy *= lhs;
}

template<typename T>
Point3D<T> operator / (const Point3D<T>& lhs, const T& rhs){
	Point3D<T> copy = lhs;
	return copy /= rhs;
}

} // namespace geometry

template<typename T>
class DefaultGenerator<typename geometry::Point2D<T>> : public Generator<typename geometry::Point2D<T>> {
	typedef typename geometry::Point2D<T> Point;
public:
	Point generate(Random& rnd) const {
		return generate(rnd, DefaultGenerator<T>());
	}

	template <typename Gen>
	Point generate(Random& rnd, Gen gen) const {
		return generate(rnd, gen, gen);
	}

	template <typename GenX, typename GenY>
	Point generate(Random& rnd, GenX genX, GenY genY) const {
		T x = rnd.next<T>(genX);
		T y = rnd.next<T>(genY);
		return Point(std::move(x), std::move(y));
	}
};

template<typename T>
class DefaultGenerator<typename geometry::Point3D<T>> : public Generator<typename geometry::Point3D<T>> {
	typedef typename geometry::Point3D<T> Point;
public:
	Point generate(Random& rnd) const {
		return generate(rnd, DefaultGenerator<T>());
	}

	template <typename Gen>
	Point generate(Random& rnd, Gen gen) const {
		return generate(rnd, gen, gen, gen);
	}

	template <typename GenX, typename GenY, typename GenZ>
	Point generate(Random& rnd, GenX genX, GenY genY, GenZ genZ) const {
		T x = rnd.next<T>(genX);
		T y = rnd.next<T>(genY);
		T z = rnd.next<T>(genZ);
		return Point(std::move(x), std::move(y), std::move(z));
	}
};

template<typename T>
class DefaultReader<typename geometry::Point2D<T>>: public Reader<typename geometry::Point2D<T>> {
	typedef typename geometry::Point2D<T> Point;
public:
	template <typename... Args>
	Point read(Args&&... args) const {
		std::pair<T, T> pair = DefaultReader<std::pair<T,T>>().read(std::forward<Args>(args)...);
		return Point(pair.first, pair.second);
	}
};

template<typename T>
class DefaultReader<typename geometry::Point3D<T>>: public Reader<typename geometry::Point3D<T>> {
	typedef typename geometry::Point3D<T> Point;
public:
	Point read(IStream& stream) const {
		return read(stream, defaultSeparator(stream));
	}
	Point read(IStream& stream, const Separator& separator) const {
		return read(stream, DefaultReader<T>(), separator);
	}

	template <typename U>
	if_reader<U, T, Point> read(IStream& stream, U reader) const {
		return read(stream, defaultSeparator(stream));
	}

	template <typename U>
	if_reader<U, T, Point> read(IStream& stream, U reader, const Separator& separator) const {
		return read(stream, reader, reader, reader, separator);
	}

	template <typename X, typename Y, typename Z>
	Point read(IStream& stream, X readerX, Y readerY, Z readerZ) const {
		return read(stream, readerX, readerY, readerZ, defaultSeparator(stream));
	}

	template <typename X, typename Y, typename Z>
	Point read(IStream& stream, X readerX, Y readerY, Z readerZ, const Separator& separator) const {
		static_assert(std::is_base_of<Reader<T>, X>::value, "reader must be Reader<T>");
		static_assert(std::is_base_of<Reader<T>, Y>::value, "reader must be Reader<T>");
		static_assert(std::is_base_of<Reader<T>, Z>::value, "reader must be Reader<T>");
		T x = stream.read<T>(readerX);
		separator.read(stream);
		T y = stream.read<T>(readerY);
		separator.read(stream);
		T z = stream.read<T>(readerZ);
		return Point(std::move(x), std::move(y), std::move(z));
	}
private:
	Separator defaultSeparator(IStream& stream) const {
		return stream.getMode() == IStream::Mode::STRICT ? " " : "";
	}
};

#pragma once

#include <algorithm>
#include <cctype>
#include <string>
#include <vector>

class BigInteger {
public:
	BigInteger() : sign(1), data(0) {}
	
	~BigInteger() {
		TESTLIB_ASSERT(sign == -1 || sign == 1);
		TESTLIB_ASSERT(data.empty() || data.back() != 0);
		TESTLIB_ASSERT(sign == 1 || !data.empty());
	}

	explicit BigInteger(intmax_t val) {
		sign = 1;
		if (val < 0) {
			sign = -1;
			val = -val;
		}
		while (val) {
			data.push_back(val % base);
			val /= base;
		}
	}

	explicit BigInteger(const std::string &s) {
		sign = 1;
		size_t pos = 0;
		while (pos < s.size() && (s[pos] == '-' || s[pos] == '+')) {
			if (s[pos] == '-')
				sign = -sign;
			++pos;
		}
		if(pos > 1)
			throw VerdictException(Verdict::FAIL, "Too many signs");
		for (size_t i = s.size(); i > pos;) {
			int x = 0;
			size_t startIndex = i > pos + baseDigits ? i - baseDigits : pos;//max, avoid underflow
			for (size_t j = startIndex; j < i; ++j)
				x = x * 10 + s[j] - '0';
			data.push_back(x);
			i = startIndex;
		}
		removeLeadingZeros();
	}

	BigInteger& operator = (const BigInteger& v) {
		sign = v.sign;
		data = v.data;
		return *this;
	}
	BigInteger& operator = (intmax_t v) {
		return *this = BigInteger(v);
	}

	BigInteger& operator += (const BigInteger &summand) {
		if (sign == summand.sign || summand.isZero()) {
			for (size_t i = 0, carry = 0; i < std::max(data.size(), summand.data.size()) || carry > 0; ++i) {
				if (i == data.size())
					data.push_back(0);
				data[i] += carry + (i < summand.data.size() ? summand.data[i] : 0);
				carry = data[i] >= base;
				if (carry)
					data[i] -= base;
			}
			return *this;
		}
		*this -= (-summand);
		return *this;
	}

	BigInteger& operator -= (const BigInteger &deduction) {
		if (sign == deduction.sign || deduction.isZero()) {
			if (abs() >= deduction.abs()) {
				for (size_t i = 0, carry = 0; i < deduction.data.size() || carry; ++i) {
					data[i] -= carry + (i < deduction.data.size() ? deduction.data[i] : 0);
					carry = data[i] < 0;
					if (carry)
						data[i] += base;
				}
				removeLeadingZeros();
				return *this;
			}
			*this = -(deduction - *this);
			return *this;
		}
		*this += (-deduction);
		return *this;
	}

	BigInteger& operator *= (int rhs) {
		long long multiplier = rhs; //avoid overflow with MIN_INT
		if (multiplier < 0) {
			sign = -sign;
			multiplier = -multiplier;
		}
		for (size_t i = 0, carry = 0; i < data.size() || carry; ++i) {
			if (i == data.size())
				data.push_back(0);
			long long cur = data[i] * (long long) multiplier + carry;
			carry = (size_t) (cur / base);
			data[i] = (int) (cur % base);
		}
		removeLeadingZeros();
		return *this;
	}

	BigInteger operator * (int multiplier) const {
		BigInteger res = *this;
		res *= multiplier;
		return res;
	}


	BigInteger& operator /= (int rhs) {
		long long divider = rhs; //avoid overflow with MIN_INT
		if (divider == 0)
			throw VerdictException(Verdict::FAIL, "division by zero");
		if (divider < 0)
			sign = -sign, divider = -divider;
		for (size_t i = data.size(), rem = 0; i-- > 0; ) {
			long long cur = data[i] + rem * (long long) base;
			data[i] = (int) (cur / divider);
			rem = (int)(cur % divider);
		}
		removeLeadingZeros();
		return *this;
	}

	BigInteger operator / (int divider) const {
		BigInteger res = *this;
		res /= divider;
		return res;
	}

	int operator % (int rhs) const {
		long long divider = rhs; //avoid overflow with MIN_INT
		if (divider < 0)
			divider = -divider;
		int m = 0;
		for (size_t i = data.size(); i-- > 0;)
			m = (data[i] + m * (long long) base) % divider;
		return m * sign;
	}
	
	BigInteger& operator %= (int divider) {
		*this = *this % divider;
		return *this;
	}
	
	BigInteger operator + (const BigInteger &summand) const {
		BigInteger res(*this);
		res += summand;
		return res;
	}
	BigInteger operator - (const BigInteger &deduction) const {
		BigInteger res(*this);
		res -= deduction;
		return res;
	}

	BigInteger operator - () const {
		BigInteger res = *this;
		if (data.size())
			res.sign = -sign;
		return res;
	}

	BigInteger abs() const {
		BigInteger res = *this;
		res.sign = 1;
		return res;
	}

	BigInteger& operator *= (const BigInteger &multiplier) {
		*this = (*this) * multiplier;
		return *this;
	}

	BigInteger operator * (const BigInteger &multiplier) const {
		BigInteger res;
		res.data.assign(data.size() + multiplier.data.size(), 0);
		res.sign = sign * multiplier.sign;
		for (size_t i = 0; i < data.size(); ++i)
			for (size_t j = 0, carry = 0; j < multiplier.data.size() || carry; ++j) {
				long long cur = res.data[i + j] + data[i] * 1LL * (j < multiplier.data.size() ? multiplier.data[j] : 0) + carry;
				res.data[i + j] = (int) (cur % base);
				carry = (size_t) (cur / base);
			}
		res.removeLeadingZeros();
		return res;
	}

	BigInteger operator / (const BigInteger &divider) const {
		return divmod(divider).first;
	}

	BigInteger operator % (const BigInteger &divider) const {
		return divmod(divider).second;
	}

	friend BigInteger gcd(BigInteger a, BigInteger b) {
		int powerOf2 = 0;
		a.sign = 1;
		b.sign = 1;
		while(!b.isZero() && !a.isZero()) {
			while(a.isEven() && b.isEven()) {
				a /= 2;
				b /= 2;
				++powerOf2;
			}
			while(a.isEven()) {
				a /= 2;
			}
			while(b.isEven()) {
				b /= 2;
			}
			a -= b;

			if(a.sign != 1){
				a.sign = 1;
				std::swap(a, b);
			}
		}
		return pow(BigInteger(2), powerOf2) * (a.isZero() ? b : a);
	}

	friend BigInteger lcm(const BigInteger &a, const BigInteger &b) {
		return a / gcd(a, b) * b;
	}

	BigInteger& operator /= (const BigInteger &divider) {
		*this = *this / divider;
		return *this;
	}

	BigInteger& operator %= (const BigInteger &divider) {
		*this = *this % divider;
		return *this;
	}
	
	static BigInteger zero() {
		return BigInteger(0);
	}
	
	static BigInteger one() {
		return BigInteger(1);
	}

	static BigInteger ten() {
		return BigInteger(10);
	}

	friend BigInteger pow(BigInteger base, uintmax_t exponent) {
		BigInteger res = one();
		while (exponent) {
			if (exponent & 1) {
				res *= base;
			}
			base *= base;
			exponent >>= 1;
		}
		return res;
	}

	bool operator < (const BigInteger &val) const {
		if (sign != val.sign)
			return sign < val.sign;
		if (data.size() != val.data.size())
			return data.size() * sign < val.data.size() * val.sign;
		for (size_t i = data.size(); i-- > 0;)
			if (data[i] != val.data[i])
				return data[i] * sign < val.data[i] * sign;
		return false;
	}

	bool operator > (const BigInteger &val) const {
		return val < *this;
	}
	bool operator <= (const BigInteger &val) const {
		return !(val < *this);
	}
	bool operator >= (const BigInteger &val) const {
		return !(*this < val);
	}
	bool operator == (const BigInteger &val) const {
		return !(*this < val) && !(val < *this);
	}
	bool operator != (const BigInteger &val) const {
		return *this < val || val < *this;
	}

	BigInteger& operator ++() {
		return *this += BigInteger(1);
	}

	BigInteger operator ++(int) {
		BigInteger copy = *this;
		++*this;
		return copy;
	}

	BigInteger& operator -- () {
		return *this -= BigInteger(1);
	}

	BigInteger operator -- (int) {
		BigInteger copy = *this;
		--*this;
		return copy;
	}

	bool isZero() const {
		return data.empty();
	}

	intmax_t toInteger() const {
		intmax_t res = 0;
		for (size_t i = data.size(); i-- > 0;)
			res = res * base + data[i];
		return res * sign;
	}
	
	std::string toString() const {
		std:: string res;
		if (data.empty())
			return "0";
		if (sign == -1)
			res = "-";

		res += std::to_string(data.back());

		for (size_t i = data.size() - 1; i-- > 0; ) {
			std::string s = std::to_string(data[i]);
			std::string addString;
			for (size_t j = 0; j < baseDigits - s.length(); ++j)
				addString += "0";
			res += addString + s;
		}
		return res;
	}
private:
	static const int base = 1000000000;
	static const size_t baseDigits = 9;
	int sign;
	std::vector<int> data;

	void removeLeadingZeros() {
		while (!data.empty() && !data.back())
			data.pop_back();
		if (data.empty())
			sign = 1;
	}

	bool isEven() const {
		return data.empty() || ((data[0] & 1) == 0);
	}

	std::pair<BigInteger, BigInteger> divmod(const BigInteger &b1) const {
 		if (b1.isZero())
			throw VerdictException(Verdict::FAIL, "division by zero");
		
		int norm = base / (b1.data.back() + 1);
		BigInteger a = (*this).abs() * norm;
		BigInteger b = b1.abs() * norm;
		BigInteger q, r;
		q.data.resize(a.data.size());

		for (size_t i = a.data.size(); i-- > 0;) {
			r *= base;
			r += BigInteger(a.data[i]);
			int s1 = r.data.size() <= b.data.size() ? 0 : r.data[b.data.size()];
			int s2 = r.data.size() <= b.data.size() - 1 ? 0 : r.data[b.data.size() - 1];
			int d = ((long long) base * s1 + s2) / b.data.back();
			r -= b * d;
			while (r < BigInteger(0))
				r += b, --d;
			q.data[i] = d;
		}

		q.sign = sign * b1.sign;
		r.sign = sign;
		q.removeLeadingZeros();
		r.removeLeadingZeros();
		return std::make_pair(q, r / norm);
	}

};

bool operator << (std::ostream& stream, const BigInteger& value) {
	return stream << value.toString();
}

template<>
class DefaultReader<BigInteger> : public Reader<BigInteger> {
public:
	BigInteger read(IStream& stream) const {
		std::string input = stream.read<std::string>();
		if (input.length() == 0)
			stream.quit(Verdict::PE, expectation("BigInteger", input));
		size_t firstDigitPos = 0;
		if (input[0] == '-') {
			++firstDigitPos;
			if (input.length() == 1 || input[1] == '0')	
				stream.quit(Verdict::PE, expectation("BigInteger", input));
		}
		if (input.length() > 1) {
			if (input[0] == '0')
				stream.quit(Verdict::PE, expectation("BigInteger", input));
		}
		for (size_t i = firstDigitPos; i < input.length(); ++i){
			if (!isdigit(input[i]))
				stream.quit(Verdict::PE, expectation("BigInteger", input));
		}
		return BigInteger(input);
	}
};

template<>
class DefaultGenerator<BigInteger>: public Generator<BigInteger>{
private:
	BigInteger generateTo (Random& rnd, const BigInteger& to) const {
		size_t qDigits = to.toString().length();
		std::string str = "1";
		for (size_t i = 0; i < qDigits; ++i)
			str += "0";
		BigInteger limit(str);
		BigInteger disallowed = limit - limit % to;
		BigInteger number;
		do {
			std::string str;
			for (size_t i = 0; i < qDigits; ++i)
				str += std::to_string(rnd.next<int>(0, 9));
			number = BigInteger(str);
		}
		while (number >= disallowed);
		return number % to;
	}
	
public:
	BigInteger generate(Random& rnd, const BigInteger& l, const BigInteger& r) const {
		if(l > r)
			throw VerdictException(Verdict::FAIL, "DefaultGenerator<BigInteger>::generate(): l > r");
		return generateTo(rnd, r - l + BigInteger::one()) + l;
	}
};

#pragma once
#include <iostream>
#include <vector>

namespace tree
{
using std::vector;

class Tree{
public:
	Tree(const vector<int>& parents) {
		graph.resize(parents.size());
		parent = parents;
		for (size_t i = 0; i < parents.size(); ++i)
			if (parents[i] == -1)
				root = i;
			else
				graph[parents[i]].push_back(i);
	}
	
	Tree(const vector<vector<size_t> >& graph, size_t root = 0): graph(graph.size()), parent(graph.size()), root(root) {
		parent[root] = -1;
		vector<char> used(graph.size(), false);
		dfsToOrderVertices(graph, used, root);
	}

	Tree(const vector<std::pair<size_t, size_t> >& edges, size_t _root = 0): Tree(edgesListToGraph(edges), _root) {}
	
	const vector<size_t>& children(size_t vertex) const {
		return graph[vertex];
	}
	
	size_t getRoot() const {
		return root;
	}
	
	bool isRoot(size_t vertex) const {
		return vertex == root;
	}
	
	Tree rehang(size_t newRoot) const;
	
	
	size_t size() const {
		return parent.size();
	}
	
	int getParent(size_t vertex) const {
		return parent[vertex];
	}
	
private:
	vector<vector<size_t> > graph;
	vector<int> parent;
	size_t root;
	void dfsToOrderVertices(const vector<vector<size_t> >& g, vector<char>& used, size_t vertex) {
		used[vertex] = true;
		for (auto to : g[vertex]) {
			if (!used[to]) {
				parent[to] = vertex;
				graph[vertex].push_back(to);
				dfsToOrderVertices(g, used, to);
			}
		}
	}
	
	static vector<vector<size_t> > edgesListToGraph(const vector<std::pair<size_t, size_t> >& edges) {
		vector<vector<size_t> > g;
		g.resize(edges.size() + 1);
		for (size_t i = 0; i < edges.size(); ++i) {
			g[edges[i].first].push_back(edges[i].second);
			g[edges[i].second].push_back(edges[i].first);
		}
		return g;
	}
};

inline vector<vector<size_t> > treeToGraph(const Tree& tree);
inline Tree shuffle(const Tree& tree, Random& rnd);
inline Tree makeParentsIdLess(const Tree& tree);

namespace utils{
inline void dfsToRenumerate(const Tree& tree, size_t vertex, vector<size_t>& resultsPermutation, size_t& usedNumbers) {
	resultsPermutation[vertex] = usedNumbers++;
	for (size_t to: tree.children(vertex))
		dfsToRenumerate(tree, to, resultsPermutation, usedNumbers);
}	
} //namespace utils ended
	

Tree Tree::rehang(size_t newRoot) const {
	vector<vector<size_t>> g = treeToGraph(*this);
	Tree resultTree(g, newRoot);
	return resultTree;
}	

inline Tree renumerateVertices(const Tree& tree, vector<size_t> permutation) {
	size_t oldRoot = tree.getRoot();
	vector<vector<size_t>> g = treeToGraph(tree);
	for (size_t v = 0; v < g.size(); ++v)
		for (auto& to : g[v])
			to = permutation[to];
	vector<vector<size_t>> resG(g.size(), vector<size_t>());
	for (size_t v = 0; v < g.size(); ++v)
		resG[permutation[v]] = g[v];
	return Tree(resG, permutation[oldRoot]);
}

inline Tree shuffle(const Tree& tree, Random& rnd) {
	vector<size_t> permutation(tree.size());
	for (size_t i = 0; i < permutation.size(); ++i) 
		permutation[i] = i;
	rnd.shuffle(permutation.begin(), permutation.end());
	return renumerateVertices(tree, permutation);
}

inline vector<vector<size_t> > treeToGraph(const Tree& tree) {
	vector<vector<size_t> > g(tree.size());
	for (size_t v = 0; v < tree.size(); v++)
		for (auto to : tree.children(v)) {
			g[v].push_back(to);
			g[to].push_back(v);
		}
	return g;
}

inline Tree makeParentsIdLess(const Tree& tree) {
	vector<size_t> permutation(tree.size());
	size_t qUsedVertices = 0;
	utils::dfsToRenumerate(tree, tree.getRoot(), permutation, qUsedVertices);
	return renumerateVertices(tree, permutation);
}


}// end of namespace tree

template<>
class DefaultGenerator<tree::Tree> : public Generator<tree::Tree> {
public:
	
	tree::Tree generate(Random& rnd, size_t numberVertices, double coefHeight = 1.0) const {
		if (coefHeight < 0.0 || coefHeight > 1.0)
			throw VerdictException(Verdict::FAIL, "DefaultGenerator<Tree> coefficient of height should be from 0.0 to 1.0");
		std::vector<std::pair<size_t, size_t> > edges(numberVertices - 1);
		for (size_t i = 1; i < numberVertices; i++) {
			size_t to = rnd.next<size_t>(0, i - 1) * coefHeight; 
			edges[i - 1] = std::make_pair(i, to);
		}
		tree::Tree tree = tree::Tree(edges);
		tree = tree::shuffle(tree, rnd);
		return tree;
	}
};

class BambooGenerator : public Generator<tree::Tree> {
public:
	tree::Tree generate(Random& rnd, size_t numberVertices) const {
		std::vector<std::pair<size_t, size_t> > edges(numberVertices - 1);
		for (size_t i = 1; i < numberVertices; i++)
			edges[i - 1] = std::make_pair(i, i - 1);
		tree::Tree tree = tree::Tree(edges);
		tree = tree::shuffle(tree, rnd);
		return tree;
	}
};

class BinaryTreeGenerator : public Generator<tree::Tree> {
public:
	tree::Tree generate(Random& rnd, size_t numberVertices) const {
		if (numberVertices % 2 == 0)
			throw VerdictException(Verdict::FAIL, "BinaryTreeGenerator: numberVertices is even");
		
		std::vector<std::pair<size_t, size_t> > edges; 
		edges.reserve(numberVertices - 1);
		std::vector<size_t> curLevel, nextLevel;
		curLevel.push_back(0); 
		size_t qProcessed = 1;
		while (qProcessed != numberVertices) {
			bool isList = true;
			for (size_t i = 0; i < curLevel.size(); i++)
				if (rnd.nextBit()) {
					size_t v = curLevel[i];
					for (size_t j = 0; j < 2 && qProcessed < numberVertices; j++) {
						edges.push_back(std::make_pair(v, qProcessed));
						nextLevel.push_back(qProcessed);
						qProcessed++;
						isList = false;
					}
				}
			if (isList) {
				size_t v = curLevel[0];
				for (size_t j = 0; j < 2 && qProcessed < numberVertices; j++) {
					edges.push_back(std::make_pair(v, qProcessed));
					nextLevel.push_back(qProcessed);
					qProcessed++;
				}
			}
			curLevel = nextLevel;
			nextLevel.clear();
		}
		tree::Tree tree = tree::Tree(edges);
		tree = tree::shuffle(tree, rnd);
		return tree;
	}
};

class BalancedKTreeGenerator : public Generator<tree::Tree> {
public:
	tree::Tree generate(Random& rnd, size_t numberVertices, size_t vertexDegree) const {
		if (vertexDegree == 0)
			throw VerdictException(Verdict::FAIL, "BalancedKTreeGenerator: vertexDegree = 0");
		std::vector<std::pair<size_t, size_t> > edges(numberVertices - 1);
		for (size_t i = 1; i < numberVertices; i++)
			edges[i - 1] = std::make_pair(i , (i - 1) / vertexDegree);
		tree::Tree tree = tree::Tree(edges);
		tree = tree::shuffle(tree, rnd);
		return tree;
	}
};

class FluffyBambooGenerator : public Generator<tree::Tree> {
public:
	tree::Tree generate(Random& rnd, size_t numberVertices) const {
		std::vector<std::pair<size_t, size_t> > edges(numberVertices - 1);
		size_t bambooSize = rnd.next<size_t>(1, numberVertices);
		for (size_t i = 1; i < bambooSize; i++)
			edges[i - 1] = std::make_pair(i, i - 1);
		for (size_t i = bambooSize; i < numberVertices; i++)
			edges[i - 1] = std::make_pair(i, rnd.next<size_t>(0, bambooSize - 1));
		tree::Tree tree = tree::Tree(edges);
		tree = tree::shuffle(tree, rnd);
		return tree;
	}
};
#pragma once

#include <iostream>

template<typename T>
class UnorderedPair {
public:
	UnorderedPair(): first(), second() {}
	UnorderedPair(const T& first, const T& second): first(first), second(second) {}

	T first, second;

private:

	T minElement() const {
		return std::min(first, second);
	}

	T maxElement() const {
		return std::max(first, second);
	}

	template<typename U>
	friend bool operator <(const UnorderedPair<U>& lhs, const UnorderedPair<U>& rhs);

	template<typename U>
	friend bool operator ==(const UnorderedPair<U>& lhs, const UnorderedPair<U>& rhs);

	template<typename U>
	friend bool operator !=(const UnorderedPair<U>& lhs, const UnorderedPair<U>& rhs);
};	

template<typename T>
bool operator <(const UnorderedPair<T>& lhs, const UnorderedPair<T>& rhs) {
	std::less<T> less;
	std::equal_to<T> equal;
	if (!equal(lhs.minElement(), rhs.minElement())) {
		return less(lhs.minElement(), rhs.minElement());
	}
	return less(lhs.maxElement(), rhs.maxElement());
}

template<typename T>
bool operator ==(const UnorderedPair<T>& lhs, const UnorderedPair<T>& rhs) {
	std::equal_to<T> equal;
	return (equal(lhs.first, rhs.first) && equal(lhs.second, rhs.second)) || 
					(equal(lhs.first, rhs.second) && equal(lhs.second, rhs.first));
}

template<typename T>
bool operator !=(const UnorderedPair<T>& lhs, const UnorderedPair<T>& rhs) {
	return !(lhs == rhs);
}

template<typename T>
std::ostream& operator << (std::ostream& stream, UnorderedPair<T> const & p){
	return stream << '{' << p.first << ',' << p.second << '}' << std::endl;
}

template<typename T>
class DefaultGenerator<UnorderedPair<T>> : public Generator<UnorderedPair<T>> {
	typedef UnorderedPair<T> Pair;
public:
	Pair generate(Random& rnd) const {
		return generate(rnd, DefaultGenerator<T>());
	}

	template <typename Gen>
	Pair generate(Random& rnd, Gen gen) const {
		T first = rnd.next<T>(gen);
		T second = rnd.next<T>(gen);
		return Pair(std::move(first), std::move(second));
	}
};

template<typename T>
class DefaultReader<UnorderedPair<T>>: public Reader<UnorderedPair<T>> {
	typedef UnorderedPair<T> Pair;
public:
	template<typename... Args>
	Pair read(Args&&... args) const {
		std::pair<T, T> pair = DefaultReader<std::pair<T,T>>().read(std::forward<Args>(args)...);	
		return Pair(pair.first, pair.second);
	}
};

#include <vector>
#include <ostream>
#include <array>
#include <cstdint>
#include <algorithm>
class Permutation {
	typedef size_t ValueType;
	typedef std::vector<ValueType>::const_iterator iterator;
public:
	explicit Permutation(const std::vector<ValueType>& permutation): permutation(permutation) {
		size_t n = permutation.size();
		std::vector<char> used(n);
		for(ValueType to: permutation){
			if(to < 0 || to >= n) {
				throw VerdictException(Verdict::FAIL, "Permutation::Permutation() Number in permutation is out of range");
			}
			used[to] = true;
		}

		for(size_t i = 0; i < n; ++i) {
			if(!used[i]){
				throw VerdictException(Verdict::FAIL, "Permutation::Permutation() Duplicate numbers in permutation");
			}
		}
	}

	template <typename Iterator>
	void applyTo(Iterator from, Iterator to) const {
		std::ptrdiff_t n = to - from;
		std::vector<typename std::iterator_traits<Iterator>::value_type> result(n);
		if(std::distance(from, to) != n)
			throw VerdictException(Verdict::FAIL, "Permutation::applyTo() Size of permutation not equal to size of range");
		for(size_t i = 0, s = static_cast<size_t>(n); i < s; ++i) {
			result[permutation[i]] = std::move(from[i]);
		}
		std::move(result.begin(), result.end(), from);
	}

	template <typename T>
	void applyTo(T& range) const {
		return applyTo(std::begin(range), std::end(range));
	}

	Permutation inverse() const {
		size_t n = size();
		Permutation result(n);
		for(size_t i = 0; i < n; ++i){
			result.permutation[permutation[i]] = i;
		}
		return result;
	}

	static Permutation identity(size_t n) {
		Permutation id(n);
		for(size_t i = 0; i < n; ++i){
			id.permutation[i] = i;
		}
		return id;
	}

	size_t operator[] (size_t index) const {
		return permutation[index];
	}

	iterator begin() const {
		return permutation.begin();
	}

	iterator end() const {
		return permutation.end();
	}

	size_t size() const {
		return permutation.size();
	}

	Permutation operator * (const Permutation& rhs) const {
		size_t n = size();
		if(n != rhs.size())
			throw VerdictException(Verdict::FAIL, "Can't multiply permutations of different sizes");
		Permutation result(n);
		for(size_t i = 0; i < n; ++i)
			result.permutation[i] = permutation[rhs.permutation[i]];
		return result;
	}

	bool operator == (const Permutation& rhs) const {
		if(size() != rhs.size()) {
			throw VerdictException(Verdict::FAIL, "Comparation of permutation of different length");
		}
		return permutation == rhs.permutation;
	}

	bool operator != (const Permutation& rhs) const {
		return !(*this == rhs);
	}

	bool operator < (const Permutation& rhs) const {
		if(size() != rhs.size()) {
			throw VerdictException(Verdict::FAIL, "Comparation of permutation of different length");
		}
		return permutation < rhs.permutation;
	}

	bool operator > (const Permutation& rhs) const {
		return rhs < *this;
	}

	bool operator <= (const Permutation& rhs) const {
		return !(*this > rhs);
	}

	bool operator >= (const Permutation& rhs) const {
		return !(*this < rhs);
	}

	friend std::ostream& operator << (std::ostream& stream, const Permutation& permutation) {
		return stream << rangeToString(permutation.begin(), permutation.end());
	}
private:

	Permutation(size_t n): permutation(n) {
	}

	std::vector<ValueType> permutation;

};

Permutation pow(Permutation p, intmax_t n) {
	bool needInverse = n < 0;
	Permutation result = Permutation::identity(p.size());
	while(n != 0) {
		if(n % 2) {
			result = result * p;
		}
		p = p * p;
		n /= 2;
	}
	if(needInverse)
		result = result.inverse();
	return result;
}

template <>
class DefaultGenerator<Permutation> : public Generator<Permutation> {
public:
	Permutation generate(Random& rnd, size_t n) {
		std::vector<size_t> result(n);
		for(size_t i = 0; i < n; ++i) {
			result[i] = i;
		}
		rnd.shuffle(result.begin(), result.end());
		return Permutation(result);
	}
};

template <>
class DefaultReader<Permutation> : public Reader<Permutation> {
public:
	template <typename... Args>
	Permutation read(IStream& stream, Args&&... args) {
		auto vector = stream.read<size_t>(std::forward<Args>(args)...);
		try {
			return Permutation(vector);
		}
		catch(VerdictException& e){
			stream.quit(Verdict::PE, e.message);
		}
	}
};
